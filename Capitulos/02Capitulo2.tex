%---------------------------------------------------------------------
%
%                          Capítulo 2
%
%---------------------------------------------------------------------

\chapter{Herramienta de Clang}



%-------------------------------------------------------------------
\section{Introducción}
%-------------------------------------------------------------------
\label{cap2:sec:introduccion}

La herramienta ast2xml conforma junto con el xmlinterpreter el cuerpo central del proyecto. Si bien ast2xml no cumple el papel más importante, suple las necesidades básicas de obtener a partir del código fuente una representación más manejable y sencilla de visualizar. Ha sido desarrollada a partir del proyecto abierto e internacional LLVM, pero se apoya principalmente en su compilador Clang.


%-------------------------------------------------------------------
\section{AST2XMLtool}
%-------------------------------------------------------------------
\label{cap2:sec:AST2XMLtool}

Al inicio del curso nos dimos cuenta de que nos podíamos aproximar al problema de distintas formas. Si bien, de una forma similar al proyecto Jsyx teniamos la posibilidad de basar nuestro proyecto en el uso de algo similar al bytecode de java pero relacionado con C++. 

%-------------------------------------------------------------------
\section{Historia de LLVM}
%-------------------------------------------------------------------
\label{cap2:sec:estado}

LLVM nació como proyecto en el año 2000 en la Universidad de Illinois en Urbana-Champaign. En 2005, junto con Apple Inc., se empezó a adaptar el sistema para varios usos dentro del ecosistema de desarrollo de Apple. Actualmente LLVM está integrado en las últimas herramientas de desarrollo de Apple para sus sistemas operativos.


El un principio ``LLVM'' eran las iniciales de ``Low Level Virtual Machine'' (Máquina Virtual de Bajo Nivel), pero esta denominación causó una confusión ampliamente difundida, puesto que las máquinas virtuales son solo una de las aplicaciones de LLVM. Cuando la extensión del proyecto se amplió incluso más, LLVM se convirtió en un proyecto que engloba una gran varriedad de otros compiladores y tecnologías de bajo nivel. Por tanto, el proyecto abandonó las iniciales y actualmente, LLVM es la manera de referirse a todas esas utilidades.


El amplio interés que ha recibido LLVM ha llevado a una serie de tentativas para desarrollar front-ends totalmente nuevos para una variedad de lenguajes. El que ha recibido la mayor atención es Clang, un nuevo compilador que soporta otros lenguajes de la familia de C (Objective-C, C++, etc..). Apoyado principalmente por Apple, se espera que Clang sustituya al comiplador del sistema GCC.

%-------------------------------------------------------------------
\section{Usando el árbol de sintaxis abstracta}
%-------------------------------------------------------------------
\label{cap2:sec:arbol}

La herramienta AST2XML efectúa como primer paso en la adaptación del código su arbol de sintaxis abstracta (Abstract Syntax Tree). 

Un árbol de sintaxis abstracta (AST) es una representación de árbol de la estructura sintáctica abstracta (simplificada) del código fuente ampliamente utilizada en los distintos compiladores del mercado. Cada nodo del árbol denota una construcción que ocurre en el código fuente. La representación del AST que emplea Clang se diferencia de la de otros compiladores en cuanto a que mantiene la semejanza con el código escrito y con el estándar de C++.

Esta estructura es obtenida mediante el uso de las distintas utilidades incluidas en el apartado de desarrollo de Clang. Mediante dichas facilidades se recorre el AST de forma recursiva conservando los detalles más importantes del código en un fichero que se devuelve al usuario.

\figura{Vectorial/figura1}{width=.5\textwidth}{fig:figura1}%
{Figura Ejemplo del AST que emplea Clang a partir de un código específico.}

%-------------------------------------------------------------------
\section{Manipulación de un AST con clang}
%-------------------------------------------------------------------
\label{cap2:sec:manipulacion}

Como se puede apreciar en la figura, la representación que se obtiene directamente de clang puede llegar a parecer abrumadoramente compleja y redundante. En momentos iniciales del proyecto tomamos la decisión de que información como la ubicación de los elementos, los tipos de las variables, o incluso el tipo de los nodos no serían necesarias en cada momento. Decidimos pues optar por una representación más acotada, clara y concisa que, expresando lo mismo, fuera lo suficientemente sencilla de manipular por el intérprete de prolog.

%-------------------------------------------------------------------
\section{Instrucciones como nodos de un fichero XML}
%-------------------------------------------------------------------
\label{cap2:sec:instrucciones}

El fichero que se le devuelve al usuario tiene formato XML y contiene información acerca de las funciones que, en el código fuente, haya declarado el usuario. Dichas funciones se encuentran englobadas en nodos function que almacenan el nombre, el número de línea, el tipo devuelto, los parámetros y el cuerpo de la función en cuestión. De los parámetros registramos su tipo y el nombre de su declaración.

\figura{Vectorial/figura2}{width=.5\textwidth}{fig:figura2}%
{Figura con ejemplo de la disposición básica de un nodo function.}

En el desarrollo del proyecto hemos tenido que, de la misma forma, asignar a cada declaración, instrucción y expresión de C++ contempladas en nuestro dominio un nodo XML que mantuviera su significado y de la misma forma no incrementara la complejidad del texto. 

%-------------------------------------------------------------------
\section{Bloques de instrucciones}
%-------------------------------------------------------------------
\label{cap2:sec:bloques}

Una noción que existe en el AST de Clang es la del CompoundStatement que representa a un bloque de código delimitado por llaves ({..}). Puesto que esperamos que el usuario haga uso de ellos sólo en compañia de otras estructuras (if, while, for o funciones), en el XML se representa con el nodo body. Que contiene los nodos de las instrucciones programadas.

%-------------------------------------------------------------------
\section*{Declaraciones e inicializaciones}
%-------------------------------------------------------------------
\label{ap1:decla}

C + + es un lenguaje fuertemente tipado, y requiere que cada variable esté declarada junto con su tipo antes de su primer uso. En un caso práctico, esto informa al compilador el tamaño reservar en memoria para la variable y la forma de interpretar su valor. Si se declaran varias variables del mismo tipo, se puede realizar en una sola instrucción.

Cuando se declara una variable, adquiere un valor indeterminado hasta que se le asigne alguno explícitamente. En C++ se contemplan tres maneras de inicializar el valor de una variable, aunque en nuestro proyecto, de cara a el uso de nuestra herramienta por parte de alumnos que están aprendiendo a programar, admitimos únicamente la forma más sencilla. 

Los nodos declaration contienen información acerca del tipo de la variable, su nombre, la línea en la que se encuentra la declaración y la expresión cuyo valor se le va a asignar.

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

%-------------------------------------------------------------------
\section*{Estructuras de control}
%-------------------------------------------------------------------
\label{ap2:control}

Las instrucciones que producen ramificaciones en la ejecución de un programa, tales como: el if, el while o el for. Para poder realizar su ejecución correctamente mantenemos en sus respectivos nodos sus señas más características.

El nodo de la instrucción if contiene el número de línea, y los nodos correspondientes a la condición que dirige su ejecución, al cuerpo del then y al cuerpo del else (en caso de estar especificado en el código). 

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

La instrucción while se traduce a un nodo que alberga como atributo el número de línea donde comienza la instrucción, y los nodos de la expresión de su condición y el bloque de instrucciones de su cuerpo.

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

La estructura del nodo de la instrucción for mantiene el número de línea, y en su interior los nodos de la declaración de su variable de control, la condición, la instrucción de avance y el cuerpo del bucle.

 \figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

%-------------------------------------------------------------------
\section*{Expresiones}
%-------------------------------------------------------------------
\label{ap3:expresiones}

Las expresiones escritas en C++ se traducen a nuestro formato en XML en nodos descritos por sus operadores, la variable a la que hacen referencia o la constante que representan. 

En caso de que estos nodos hagan referencia a un operador, contienen información acerca del tipo de este (binario, unario, asignación, etc...) y de las expresiones que contienen. 

Las expresiones que se refieren a variables almacenan el nombre de estas y de forma equivalente las que representan constantes guardan su valor.

Un caso particular de las expresiones sería el de las llamadas a función. Dado que en el subconjunto de C++ en el que se mueve nuestra herramienta tan sólo contemplamos la utilización de funciones, la llamada a otros métodos.

%-------------------------------------------------------------------
\section*{Operadores de asignación}
%-------------------------------------------------------------------
\label{ap4:operadores}

Para representar las instrucciones de asignación nos expresamos mediante los nodos assignment y assignmentOperator, conteniendo el nombre de la variable, la línea y la expresión de la cual se calcula el valor. 

 \figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}


%-------------------------------------------------------------------
%section*{\NotasBibliograficas}
%-------------------------------------------------------------------


%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
