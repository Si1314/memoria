%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------

\chapter{Interfaz gráfica de usuario de SymC++}

\pagestyle{plain}

En este capítulo explicaremos brevemente cual es la arquitectura de la interfaz desarrollada y su relación como núcleo central y enlace con todos los componentes de la herramienta y el usuario.  Este capítulo está dirigido a aquellas personas interesadas en conocer las decisiones de diseño que hemos tomado, así como la estructura y funcionalidades implementadas.

Este capítulo no pretende ser un manual de usuario o de instalación, el cual se encuentra en el capítulo de apéndices.

%-------------------------------------------------------------------
\section{Java en el desarrollo de interfaces de usuario}
%-------------------------------------------------------------------

Para el desarrollo de nuestra interfaz de usuario hemos obtado por utilizar el lenguaje de programación de Java y las clases AWT y Swing.

Como una breve introducción Java es un lenguaje de programación de propósito general, concurrente, orientado a objetos y basado en clases que fue diseñado específicamente para tener tan pocas dependencias de implementación como fuera posible. Su intención es permitir que los desarrolladores de aplicaciones escriban el programa una vez y lo ejecuten en cualquier dispositivo (conocido en inglés como WORA del inglés ``write once, run anywhere'' lo que en su traducción sería ``escribe una vez, y ejecuta en cualquier lugar''), lo que quiere decir que el código que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra. Java es, a partir de 2012, uno de los lenguajes de programación más populares en uso, particularmente para aplicaciones. Es por estas características por lo que decidimos desarrollarlo usando dicho lenguaje.

Desde sus inicios el entorno Java ya contaba con una biblioteca de componentes gráficos conocida como ``AWT''. Esta biblioteca estaba concebida como una API estandarizada que permitía utilizar los componentes nativos de cada sistema operativo, pero en la práctica esta tecnología no funcionó. Más adelante, apareció ``Swing'' el cual apoyándose en AWT introdujo un mecanismo que permitía que el aspecto de cada componente pudiese cambiar sin introducir cambios sustanciales en el código de la aplicación, esto permitio a Swing emular la apariencia de los componentes nativos manteniendo las ventajas de la independencia de plataforma.

Hoy en día existen multitud de aplicaciones gráficas de usuario basadas en Java. El entorno de ejecución Java (JRE) se ha convertido en un componente habitual en los PC de usuario de los sistemas operativos más usados en el mundo. Además, muchas aplicaciones Java lo incluyen dentro del propio paquete de la aplicación de modo que se ejecuten en cualquier ordenador.

%-------------------------------------------------------------------
\section{Estructura de la herramienta}
%-------------------------------------------------------------------

Para ilustrar mejor la estructura, así como para mostrar mejor la relación entre el usuario y la herramienta, y entre las diferentes secciones que la componen acompañamos la siguiente figura:

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.9\textwidth]%
{Imagenes/Vectorial/esquemaHerramienta}
\caption{Figura que muestra las conexiones entre todas las partes de la herramienta.}
\end{center}
\end{figure}

Como se puede observar, la herramienta SymC++ necesita un código en C++ sobre el que realizar la ejecucución y una serie de parámetros para el intérprete, y a partir de ahí la propia interfaz de usuario envía todo lo necesario tango al AST2XML como al Intérprete Simbólico, para que a través de la salida generada, sea procesada de nuevo por la interfaz y se pueda mostrar al usuario. Por tanto, como ya hemos detallado a lo largo de los capítulos anteriores, la herramienta SymC++ está compuesta por tres secciones, a su vez todas comunicadas entre sí gracias a la interfaz, para de este modo facilitar la tarea de depuración al usuario.

%-------------------------------------------------------------------
\subsection{Comunicación entre la interfaz y ast2xml y el intérprete}
%-------------------------------------------------------------------

Para la comunicación entre la interfaz, tanto con AST2XML como con el Intérprete Simbólico, hemos creado dos scripts con comandos shell, los cuales son lanzados desde java como procesos externos. Pero del mismo modo que estos comandos son lanzados desde la interfaz, también pueden ser ejecutados desde nuestro terminal de comandos, de este modo, podemos generar tanto el XML del árbol sintáctico anotado, como el XML con la solución del intérprete simbólico, sin necesidad de usar la interfaz de usuario. Esta solución da una mayor portabilidad a ambas herramientas, así como aportar una mayor flexibilidad al usuario para que pueda usar el método con el que se sienta más cómodo. Los comandos los detallamos  a continuación:

\begin{itemize}
\item \textbf{Comando para la ejecución de AST2XML.}\\ 
\begin{center}
\$./ast2xml <fichero C++> <fichero XML salida>
\end{center}
\item \textbf{Comando para la ejecución del Intérprete Simbólico.}\\
\begin{center}
\$./interpreter.pl interpreter(<fichero XML ast2xml>, <fichero XML salida>, <minimo entero>, <maximo entero>, <profundidad bucle>, <nombre función>)
\end{center}
\end{itemize}

Hay que tener en cuenta, una serie de requisitos para que la herramienta funcione correctamente. Es necesario que el usuario seleccione al abrir por primera vez SymC++ dónde ha instalado que la herramienta de AST2XML, la cual se guardará en un archivo de configuración. Por tanto, al lanzar la ejecución, tomará dicho directorio como herramienta y será la encargada de generar el archivo XML del árbol de ejecución, en este caso es responsabilidad del usuario seleccionar correctamente tal archivo para una correcta ejecución. Por otro lado para la ejecución de SymC++ es necesario un archivo con el código C++, por tanto si el usuario abre un archivo con el código, antes de la ejecución se realizará un autoguardado, por otro lado, en el caso de que el usuario haya escrito el código completo en nuestra herramienta, la herramienta pedirá al usuario que guarde dicho archivo antes de poder ejecutar.





%-------------------------------------------------------------------
\section{Diseño}
%-------------------------------------------------------------------

A la hora de desarrollar la interfaz para el cliente, el principal problema al que nos enfrentamos era la búsqueda de una interfaz intuitiva, fácil y que ofreciera todas las funcionalidades de depuración que buscamos para los estudiantes a los que está orientada esta herramienta. 
Es por esto que buscamos una vista de cliente, en la que toda la información resultante de la ejecución simbólica esté disponible en la vista principal.
Para el desarrollo de la interfaz hemos utilizado una librería de ``Synthetica Look And Feel'', librería bajo licencia gratuita para usos no comerciales. Esta librería nos ha permitido dar una mayor vistosidad a la aplicación además de facilitarnos algunas cuestiones relativas al diseño.
Por otro lado, todas las imágenes referentes a los botones también están bajo licencia gratuita para usos no comerciales. 

Para la estructura de la interfaz, hemos utilizado ``MigLayout'', el cual se encuentra bajo licencia pública GNU GPL. Este layout nos facilita la distribución de la pantalla y del mismo modo, ofrece una mayor simplicidad y escalabilidad para la herramienta.

%-------------------------------------------------------------------
\section{Funcionalidades}
%-------------------------------------------------------------------

Las funcionalidades referentes a la interfaz del cliente son las básicas de cualquier editor de texto e incluso compilador de código. Hay que partir de la base, de que en nuestro proyecto lo más relevante no es la interfaz, sino todo el trabajo que hay detrás con la ejecución simbólica.

Como funcionalidades de depuración cabe destacar la visión en formato árbol de los XMLs generados tanto por Clang como por Prolog, los cuales contienen toda la información relativa al árbol sintáctico anotado del archivo C++ y al resultado de la ejecución simbólica respectivamente.

Referente a la visión del área de texto, para darle un aspecto de editor de código hemos añadido la visibilidad del número de línea.

Por tanto, para implementar las funcionalidades descritas, así como otras varias hemos utilizado las siguientes clases de código, todas bajo la licencia GNU, las cuales les hemos realizado las modificaciones necesarias para cumplir nuestro diseño :

\begin{itemize}
\item LineNumbers.java [1] (http://javaknowledge.info/jtextpane-line-number/)
\item MultiLineCellRenderer.java [2] (http://www.java2s.com/Code/Java/Swing-Components/MultiLineCellExample.htm)
\item XML2JTree.java [3] (cse.unl.edu/~reich/XML/DOM/XML2JTree.java)
\end{itemize}




%-------------------------------------------------------------------
\section{Directorio de archivos}
%-------------------------------------------------------------------

El sistema de archivos de la aplicación está dividido en varios directorios:
\begin{itemize}
\item files : Directorio en el que se almacenan todos los archivos generados, tanto los XMLs generados por Clang y el intérprete, como el archivo de c++ que se va a ejecutar. En este directorio, se incluyen los archivos ``BuiltinsIO.h'' y ``BuiltinsSTD.h'' necesarios para el uso de las funciones de entrada y salida.
\item tools: En este directorio se incluyen los archivos prolog necesarios para que el intérprete funcione y los comandos shell que realizan la llamada tanto a la herramienta Clang como al intérprete Prolog.
\item img: Directorio en el que se incluyen todas las imágenes necesarias para la interfaz.
\item libs: Directorio en el que se incluyen todas las librerías necesarias para que la interfaz funcione, las cuales son las referentes al estilo, synthetica, y al layout, miglayout.
\end{itemize}


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
