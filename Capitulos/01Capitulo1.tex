%---------------------------------------------------------------------
%
%                          Capítulo 1
%
%---------------------------------------------------------------------

\chapter{Introducción}

%-------------------------------------------------------------------
\section{Motivación de la propuesta}
%-------------------------------------------------------------------
\label{cap1:sec:motivacion}

El proyecto nace de la idea y la necesidad de utilizar una herramienta útil para los estudiantes de iniciación a la programación.

El problema al que se enfrentan los estudiantes es cuando los ejercicios a resolver crecen en complejidad, los programas también y normalmente no se comportan como deben para todos los casos. Escribir programas totalmente correctos requiere el uso de una serie de metodologías que en general resultan muy complejas para los estudiantes en los primeros cursos. La mayoría de ellos siguen una mecánica de prueba-error, es decir, escriben los programas sin pararse a pensar demasiado acerca de su corrección, y luego los prueban para ver si se comportan como esperan. Estas pruebas normalmente no son lo suficientemente exhaustivas y por lo tanto los estudiantes normalmente no son ni siquiera conscientes de las incorrecciones de sus programas. Desgraciadamente, los mecanismos y herramientas que ayudan en el testing y depuración de programas son en general demasiado avanzados, como por ejemplo lo son los para poder ser utilizados por programadores inexpertos.

En este caso concreto, la herramienta está desarrollada para el lenguaje de C++, puesto que es el utilizado en los primeros cursos de los grados de las Facultades de Informática, Estudios Estadísticos y Matemáticas, y concretamente es el utilizado en la asignatura de primer curso de Fundamentos de Programación en nuestra Facultad.

Dado este problema aparece nuestro proyecto, como una herramienta sencilla e intuitiva que pueda mostrar de un modo natural el recorrido de un programa por sus diferentes ramas y los resultados que obtendría en cada uno de ellos. Esta herramienta ofrecerá una solución a la verificación de programas sencillos para estudiantes de iniciación, y de este modo acercar las herramientas de testing y depuración de un modo más visual y fácil.

%-------------------------------------------------------------------
\section{Estado del arte y trabajos relacionados}
%-------------------------------------------------------------------
\label{cap1:sec:estytra}

%-------------------------------------------------------------------
\subsection{C++ y Clang}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

%-------------------------------------------------------------------
\subsubsection*{C++, un lenguaje con historia}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

C++ es un lenguaje de programación diseñado a mediados de los años 1980 por Bjarne Stroustrup en los Laboratorios de Bell. C++ nació como extensión del lenguaje de programación C, al mismo tiempo que proporciona un cierto número de características que \"engalanan\" dicho lenguaje. El nombre de C++ fue propuesto por Rick Mascitti en el año 1983, cuando el lenguaje fue utilizado por primera vez fuera de un laboratorio científico. Hasta ese momento se había utilizado el nombre de \"C con clases\". 

Se puede decir que C++ es un lenguaje que abarca tres paradigmas de programación: la programación estructurada, la programación genérica y la programación orientada a objetos. Es un lenguaje de programación intermedio, puesto que se puede utilizar tanto para escribir software de bajo nivel, como drivers y componentes de sistemas operativos, como para el desarrollo rápido de aplicaciones.

Actualmente existe un estándar, denominado ISO C++, al que se han adherido la mayoría de los fabricantes de compiladores más modernos. Existen también algunos intérpretes, tales como ROOT.

Las príncipales características de este lenguaje son las facilidades que proporciona para la programación orientada a objetos y para el uso de plantillas o programación genérica. Además posee una serie de propiedades dificiles de encontrar en otros lenguajes como es la posibilidad de redefinir los operadores o poder crear nuevos tipos, que se comporten como tipos fundamentales.

%-------------------------------------------------------------------
\subsubsection*{Clang y LLVM}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

Clang es un front end de compilador para los lenguajes de programación C, C++, Objective-C y Objective-C++. Usa LLVM como su back-end y ha sido parte del ciclo de lanzamiento de LLVM desde la versión 2.6. Está diseñado para ofrecer un reemplazo de GNU Compiler Collection (GCC). Es open-source, y varias compañías de software están involucradas en su desarrollo, incluyendo a Google y Apple. Su código fuente está bajo la licencia University of Illinois/NCSA. El proyecto Clang incluye además un analizador estático de software y varias herramientas de análisis de código.

Por otro lado, LLVM (anteriormente conocido como Low Level Virtual Machine, o Máquina Virtual de Nivel Bajo) es una infraestructura para desarrollar compiladores, escrita a su vez en el lenguaje de programación C++, que está diseñada para optimizar el tiempo de compilación, el tiempo de enlazado, el tiempo de ejecución y el \"tiempo ocioso\" en cualquier lenguaje de programación que el usuario quiera definir. Implementado originalmente para compilar C y C++, el diseño agnóstico de LLVM con respecto al lenguaje, y el éxito del proyecto han engendrado una amplia variedad de lenguajes, incluyendo Objective-C, Fortran, Ada, Haskell, bytecode de Java, Python, Ruby y otros.

LLVM suministra las capas intermedias de un sistema de compilado completo, tomando el código en formato intermedio (IF, en sus siglas en inglés) de un compilador y emitiendo un IF optimizado. Este nuevo IF puede ser convertido y enlazado en un código ensamblador dependiente de la máquina concreta para una plataforma objetivo. LLVM puede aceptar el IF generado por la cadena de herramientas GCC, permitiendo así que sea utilizado con todos los lenguages que a su vez son aceptados por GCC. LLVM también puede generar código máquina relocalizable en el momento de compilación o de enlazado, o incluso código máquina binario en el momento de ejecución.

%-------------------------------------------------------------------
\subsection{Verificación y Análisis}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

Actualmente el software es uno de los productos más requeridos en el mundo. Tal demanda de software implica procesos de desarrollo más intensos, exhaustivos y menos prestos a errores. Siendo la corrección de fallos la etapa en la que más recursos se invierten y en la que hay más interés por mejorar su eficiencia. 

A día de hoy en el mercado existen paquetes de herramientas capaces de ofrecer a los desarrolladores detección de errores y estudios sobre la ejecución de sus programas. Existen varias maneras de verificar la correctitud de un programa.

%-------------------------------------------------------------------
\subsubsection*{Lógicas}
%-------------------------------------------------------------------
\label{ap2:sec:clang}



%-------------------------------------------------------------------
\subsubsection*{Sistemas de tipos}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

Asignar tipos de datos (tipificar) da significado a colecciones de bits. Los tipos de datos normalmente tienen asociaciones tanto con valores en la memoria o con objetos como con variables. Como cualquier valor simplemente consiste en un conjunto de bits de un ordenador, el hardware no hace distinción entre dirección de memoria, código de instrucción, caracteres, enteros y números en coma flotante. Los tipos de datos informan a los programas y programadores cómo deben ser tratados esos bits.

Al proceso de verificar e imponer los límites impuestos por los tipos de datos, conocido como comprobación o checkeo de tipificación, puede ocurrir tanto en la compilación (comprobación estática) o en la ejecución (comprobación dinámica). La elección entre sistemas de tipificación dinámico y estático requiere algunas contraprestaciones:

\begin{itemize}
\item El tipado estático busca errores en los tipos de datos durante la compilación. Esto debería incrementar la fiabilidad de los programas procesados. Sin embargo, los programadores, normalmente, están en desacuerdo en cómo los errores de tipos de datos más comunes ocurren, y en qué proporción de estos errores que se han escrito podrían haberse cazado con un tipado estático.  Los defensores de los lenguajes fuertemente tipados han sugerido que casi todos los errores pueden ser considerados errores de los tipos de datos.
\item El tipado dinámico permite a los compiladores e intérpretes ejecutarse más rápidamente, debido a que los cambios en el código fuente en los lenguajes dinámicamente tipados puede resultar en menores comprobaciones y menos código que revisar. Esto también reduce el ciclo editar-compilar-comprobar-depurar. El tipado dinámico típicamente hace que la metaprogramación sea más poderosa y fácil de usar.
\end{itemize}


%-------------------------------------------------------------------
\subsubsection*{Análisis estático}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

El análisis estático de software es un tipo de análisis que se realiza sin ejecutar el programa. En la mayoría de los casos se realiza sobre el código fuente y en otros casos se realiza sobre el código objeto.

Dicho término se aplica a los análisis realizados por parte de una herramienta automática sobre el programa sin que este se ejecute. La industria ha reconocido los métodos de análisis estático como elementos clave a la hora de mejorar la calidad de programas complejos. Un uso comercial creciente del análisis estático es la verificación de las propiedades de software utilizadas en sistemas informáticos críticos para la seguridad y la localización de código vulnerable, pero también se incluyen una viariedad de métodos formales que verifican ciertas propiedades del programa. Por ejemplo, el uso de este tipo de análisis está muy extendido en los campos de la medicina, la aviación o la energía nuclear, donde no se pueden permitir errores ni riestos.


%-------------------------------------------------------------------
\subsubsection*{Chequeo de modelos (Model checking)}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

La verificación de modelos (o Model checking) es un método automático de verificación de un sistema formal, en la mayoría de las ocasiones derivado del hardware o del software de un sistema informático. El sistema es descrito mediante un modelo, que debe satisfacer una especificación formal descrita mediante una fórmula, a menudo escrita en alguna variedad de lógica temporal.

El modelo suele estar expresado como un sistema de transiciones, es decir, un grafo dirigido, que consta de un conjunto de vértices y arcos. Un conjunto de proposiciones atómicas se asocia a cada nodo. Así pues, los nodos representan los estados posibles de un sistema, los arcos posibles evoluciones del mismo, mediante ejecuciones permitidas, que alteran el estado, mientras que las proposiciones representan las propiedades básicas que se satisfacen en cada punto de la ejecución.

Formalmente, el problema se representa de la siguiente manera: Dada una propiedad deseada, expresada como una fórmula en lógica temporal p, y un modelo M con un estado inicial s.

Los inventores del método, Edmund M. Clarke, E. Allen Emerson y Joseph Sifakis, recibieron el Premio Turing 2007 de la ACM, en reconocimiento de su fundamental contribución al campo de las ciencias de la computación.

%-------------------------------------------------------------------
\subsubsection*{Ejecución simbólica}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

La ejecución simbólica o evaluación simbólica es un modo de analizar programas para determinar qué entradas causan cada parte del programa a ejecutar. En este tipo de programas, un intérprete recorre el programa donde cada variable asume un valor simbólico acotado. Este recorrido dará como resultado expresiones en términos de dichos símbolos de expresiones y variables y las limitaciones en cuanto a los símbolos de los posibles resultados de cada rama condicional. 

Dicho recorrido nos permite determinar las condiciones que deben ser verificadas por los datos de ingreso para que un camino particular se ejecute, y la relación entre los valores ingresados y producidos en la ejecución de un programa. 

Este procedicimiento aplicado al hardware recibe el nombre de simulación simbólica.


%-------------------------------------------------------------------
\subsection{Testing}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

En relación con la sección anterior nacen las pruebas de software(o testing en inglés) son las investigaciones empíricas y técnicas cuyo objetivo es proporcionar información objetiva e independiente sobre la calidad del producto a la parte interesada.

Estas pruebas se diferencian de las herramientas de verificación y análisis en que las pruebas garantizan la correctitud de los programas para esos test, pero es posible que dichos test no abarquen todas las posibilidades o ramas de ejecución de un programa, de tal modo que el programa podría no estar correcto para todas sus posibilidades como si garantiza la verificación y el análisis. A continuación detallamos algunas de estas herramientas de testing.

%-------------------------------------------------------------------
\subsubsection*{Frameworks xUnit}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

Durante su trabajo en los laboratorios de Xerox Park, Kent Beck desarrollo un framework para realizar test unitarios en el lenguaje de programación {\it Smalltalk} que estaba desarrollando. Dicho framework se llamaba sUnit. sUnit Permitía agrupar los tests en suites, el lanzamiento jerárquico de éstos y realizar para cada test la comparación entre el valor obtenido y el valor esperado para determinar la corrección de la funcionalidad testeada. Este framework ha sido llevado a una gran variedad de lenguajes de programación ({\it JUnit}, {\it XSLTUnit}, {\it PhpUnit}, {\it PyUnit}...). xUnit es el nombre con el que se designa genéricamente a todos estos frameworks.

Una de las características de los tests xUnit es la expansión y el alto grado de utilización de esta herramienta por todo el mundo.



%-------------------------------------------------------------------
\subsubsection*{Generación de tests}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

El objetivo de las pruebas es presentar información sobre la calidad del producto a las personas responsables, por tanto la información requerida puede ser de lo más variada. Esto hace que el proceso de testing sea dependiente del contexto, no existen las {\it mejores pruebas}, toda prueba puede ser ideal para una situación o completamente inutil o perjudicial para otra. A continuación detallamos algunas de los diferentes enfoques para la generación de tests:
\begin{itemize}
\item Pruebas de caja blanca (white-box). Estas pruebas se centran en los detalles procedimentales del software, por lo que su diseño está fuertemente ligado al código fuente. El testeador escoge distintos valores de entrada para examinar cada uno de los posibles flujos de ejecución y cerciorarse de que se devuelven los valores de salida adecuados. Puesto que están basados en una implementación concreta, si esta se modifica, normalmente también tendrán que rediseñarse las pruebas. A pesar de que este enfoque permite diseñar pruebas que cubran una amplia variedad de casos podría pasar por alto partes incompletas de la especificación o requisitos faltantes.
\item Pruebas de caja negra (black-box). Estas pruebas se centran en el estudio de las entradas y las salidas generadas, independientemente de su funcionamiento interno, es decir, nos interesa su forma de interactuar entendiendo {\it qué es lo que hace} pero sin importarnos el {\it cómo lo hace}. Unas pruebas de test basadas en este sistema será más fácil de entender ya que permitirá dar una visión más clara del conjunto, el sistema también será más robusto y fácil de mantener, en caso de fallo este podrá ser aislado y abordado más ágilmente.
\item Testing aleatorio o random. Buscando ampliar el ámbito de pruebas de unidad, se han aplicado diversas técnicas que van desde la automatización de pasos, hasta los enfoques de generación de objetos de manera aleatoria. En este caso concreteo, la generación de tests de forma aleatoria es un caso particular de las pruebas de caja negra, donde las pruebas se realizan con entradas generadas de manera aleatoria e independiente. Los resultados se comparan con las especificaciones del software en prueba para verificar si los resultados pasan el test o no.

\end{itemize}

%-------------------------------------------------------------------
\subsection{Programación con restricciones}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

La programación con restricciones es un paradigma de la programación en informática, donde las relaciones entre las variables son expresadas en terminos de restricciones o ecuaciones. Este paradigma representa uno de los mayores desarrollos en los lenguajes de programación desde 1990 y ha sido identificada como una dirección estratégica en la investigación en computación.

Se trata de un paradigma de programación basado en la especificación de un conjunto de restricciones las cuales deben ser satisfechas por cualquier solución del problema planteado, en lugar de especificar los pasos para obtener dicha solución. El enfoque de este tipo de programación se basa principalmente en especificar un estado en el cual una gran cantidad de restricciones sean satisfechas simultaneamente. Un problema se define típicamente como un estado de la realidad	en el cual existe un número de variables con valor desconocido. Un programa basado en restricciones busca dichos valores para todas las variables.

La programación con restricciones se relaciona mucho con la programación lógica, de hecho cualquier programa lógico puede ser traducido a un programa con restricciones y viceversa, en muchas ocasiones los programas lógicos son traducidos a programas con restricciones puesto que la solución es mucho más eficiente. 

Los lenguajes de programación con restricciones son típicamente ampliaciones de otro lenguaje. El primer lenguaje utilizado a tal efecto fue Prolog. Por esta razón este campo fue llamado inicialmente Programación Lógica con Restricciones.

La programación lógica con restricciones es un caso particular de la programación con restricciones, en el cual la programación lógica se extiende para incluir conceptos de la programación con restricciones. Por tanto, un programa lógico con restricciones es un programa lógico que contiene restricciones en el cuerpo de sus claúsulas. Por ejemplo, la claúsula {\it A(X,Y) :- X+Y>0, B(X), C(Y)} es un ejemplo de una cláusula con restricciones donde {\it X+Y>0} es la restriccion y {\it B(X), C(Y)} son literales al igual que en programación lógica.

Al igual que en la programación lógica, los programas se ejecutan buscando demostrar un objetivo que puede contener restricciones además de los literales. Una prueba para un objetivo se compone de claúsulas cuyos cuerpos satisfacen las restricciones y literales que se pueden probar usando otras claúsulas. La ejecución se realiza a través de un intérprete, que empieza desde un objetivo y recursivamente escanea el resto de claúsulas para probar el objetivo.

%-------------------------------------------------------------------
%\subsubsection{Revisiones (Software Reviews)}
%-------------------------------------------------------------------
%\label{ap1:sec:revisiones}

%Hechas por personas, por lo general involucradas en el proceso de desarrollo, expertas en la materia. Son reuniones en las que los revisores analizan el código y lo estudian en grupo con el objetivo de encontrar errores. Existen protocolos estandarizados por la asociación IEEE que rigen el orden de estas revisiones. Dependiendo de los conductores del análisis y del objetivo de este, cambia la denominación de la revisión.

%-------------------------------------------------------------------
%\subsubsection*{Peer Review}
%-------------------------------------------------------------------
%\label{ap1:peer}

%Realizada por el propio autor del código o un compañero y su objetivo es evaluar el contenido técnico y la calidad del software.

%-------------------------------------------------------------------
%\subsubsection*{Management Reviews}
%-------------------------------------------------------------------
%\label{ap2:management}

%Cuentan con la asistencia de los directivos o superiores, el objetivo es comprobar el trabajo realizado y sopesar el trabajo futuro.

%-------------------------------------------------------------------
%\subsubsection*{Audit Reviews}
%-------------------------------------------------------------------
%\label{ap2:audit}

%La realiza personal externo al proyecto y busca irregularidades en cuanto a las especificaciones, estándares o acuerdos empresariales.

%-------------------------------------------------------------------
%\subsubsection{Análisis dinámico}
%-------------------------------------------------------------------
%\label{ap1:sec:dinamico}

%Supone la ejecución del programa y observar su comportamiento. Para que el anáilisis sea efectivo de debe realizar con los suficientes casos de prueba. 
%Estos casos de prueba representan los comportamientos que se esperan del programa en distintas condiciones de ejecución. Para asegurar la efectividad de las pruebas se pueden usar distintas técnicas como estudiar la cobertura del código (comprobar que en diferentes ejecuciones de un programa se pasa por todas las instruccciones al menos una vez) o el uso de programas fuzzers que ayudan a asegurar que una porción adecuada del conjunto de posibles comportamientos del programa ha sido observada.

%-------------------------------------------------------------------
%\subsubsection*{Verificacion de modelos(Model cheking)}
%-------------------------------------------------------------------
%\label{ap1:verificacion}

%Método en el cual el programa y su especificación se expresan matemáticamente con el objetivo de verivicar su correctitud.

%-------------------------------------------------------------------
%\subsubsection*{Lógica de Hoare}
%-------------------------------------------------------------------
%\label{ap1:hoare}

%Se emplea un sistema con un conjunto de reglas lógicas con las que razonar rigurosamente la correctitud del programa.

%-------------------------------------------------------------------
%\subsubsection*{Análisis del flujo de datos}
%-------------------------------------------------------------------
%\label{ap2:flujo}

%Es una técnica en la que se recoge información acerca del conjunto de posibles valores calculados en distintos puntos del programa. Se utiliza para estudiar a que partes del programa se podría propagar un valor en particular asginado a una variable. 

%-------------------------------------------------------------------
%\subsubsection*{Interpretación abstracta}
%-------------------------------------------------------------------
%\label{ap3:abstracta}

%Es un método que modela el efecto de las instrucciones del programa en la máquina mediante una ``ejecución'' basada en las propiedades matemáticas de cada instrucción. La máquina sobre la que ésta se lleva a cabo es una representación simplificada de la máquina verdadera. Esta máquina abstracta aproxima el comportamiento del sistema haciéndolo más fácil de analizar.

%-------------------------------------------------------------------
\subsection{Trabajos relacionados}
%-------------------------------------------------------------------
\label{cap1:sec:trabajos}

Como hemos mencionado anteriormente la ejecución simbólica, no es algo nuevo y ha adquirido protagonismo en los últimos años. Es por esto que podemos encontrar varios proyectos orientados al testing de diversos estilos, aquí describimos algunos de ellos para contextualizar nuestro proyecto.

%-------------------------------------------------------------------
\subsubsection{PEX}
%-------------------------------------------------------------------
\label{ap1:sec:pex}

PEX es una herramienta desarrollada por Microsoft par a la generación automática de casos de prueba. Esta herramienta genera entradas de test para programas .NET, por tanto puede analizar cualquier programa que se ejecute en una máquina virtual .NET y soporta lenguajes como C\#, Visual Basic y F\#.

El enfoque de PEX se caracteriza por implementar la ejecución dinámica simbólica, pero también permite el uso de ejecucución concreta de valores para simplificar las restricciones, las cuales serían resuletas por el resolutor SMT. Por tanto, mediante un proceso iterativo, PEX realiza una ejecución concreta del método a analizar y examina la traza de ejecución buscando ramas no exploradas. Una vez ha encontrado una rama no explorada, usa la ejecu-ción simbólica y un sistema resolutor de restricciones para generar valores concretos que exploren dicha rama. Este proceso se repite hasta obtener el recubrimiento deseado.

El hecho de combinar la ejecución simbólica con la concreta permite en muchos casos incrementar la escalabilidad y tratar con situaciones donde la ejecución no depende sólo del código sino de factores externos. Se entiende por factores externos el uso de librerías nativas, llamadas al sistema operativo o interacciones con el usuario. Ante este tipo de situaciones, la ejecución simbólica presenta grandes limitaciones y en general, no se puede aplicar.

Esta herramienta se puede integrar en el entorno de desarrollo de Visual Studio facilitando su uso como un añadido (Add\-on).

Como proyecto interesante relacionado con PEX existe el juego Code Hunt también desarrollado por Microsoft. En este juego el jugador debe escribir código para avanzar en el juego. La relacióncon PEX es que lo que se muestra al jugador son las entradas y salidas, y mediante ejecución simbólica se evaluará el código escrito y de este modo poder avanzar.

%-------------------------------------------------------------------
\subsubsection{PET}
%-------------------------------------------------------------------
\label{ap2:sec:pet}

PET (Partial Evaluation-based Test Case Generator for Bytecode) es una herramienta cuyo propósito es generar casos de prueba de forma automática para programas escritos en bytecode (código de bytes de Java). PET adopta el enfoque previamente comentado, esto es, ejecuta el bytecode simbólicamente y devuelve como salida un conjunto de casos de prueba (test-cases). Cada caso de prueba está asociado a una rama del árbol y se expresa como un conjunto de restricciones sobre los valores de entrada y una descripción de los contenidos de la memoria dinámica (o heap).

Las restricciones de la memoria dinámica imponen condiciones sobre la forma y contenidos de las estructuras de datos del programa alojadas en esta misma. PET utiliza de un resolutor de restricciones que genera valores concretos a partir de estas restricciones, permitiendo la construcción de los
tests propiamente dichos.

PET puede usarse a través de una interfaz de línea de comandos o bien usando una interfaz web. Además soporta una variedad de opciones interesantes, como la elección de criterios de recubrimiento o la generación de tests jUnit. Estas opciones se describen con más detalle en el segundo capítulo.

%-------------------------------------------------------------------
\subsubsection{jSYX}
%-------------------------------------------------------------------
\label{ap3:sec:jsyx}

jSYX es un proyecto desarrollado el curso pasado como trabajo de Sistemas Informáticos. Este proyecto se basa en una máquina virtual de Java que permite la ejecución simbólica de archivos .class de Java, de este modo puede ser utilizado para el desarrollo automático de Tests. 

El enfoque de jSYX es el uso de del Bytecode de Java como lenguaje de ejecución. Esta herramienta permite la ejecución recibiendo como parámetros una clase y su método, y de este modo permite la ejecución simbólicamente o de manera concreta. Por otra lado se podrá obtener información sobre el bytecode del archivo .class.

%-------------------------------------------------------------------
\subsubsection{jPET}
%-------------------------------------------------------------------
\label{ap4:sec:jpet}

Al igual que el detallado en la sección anterior, jPET también se trata de un proyecto de Sistemas Informáticos, en este caso desarrollado durante el curso 2010/2011. Este proyecto se basa en PET, la herramienta detallada anteriormente, y es una extensión de dicha herramienta para poder utilizarse en programas Java de alto nivel e integrarse en Eclipse, con el objetivo de poder usar los resultados obtenidos por PET durante el proceso de desarrollo de software.

El enfoque de jPET es el tratamiento de la información generada por PET con el objetivo de presentarla al usuario de una manera más fácil, sencilla e intuitiva. Es por esto que incorpora un visor de casos de prueba para mostrar el contenido de memoria antes y después de la ejecución, una herramienta de depuración, para ver los resultados mostrando la secuencia de instrucciones que el caso de prueba ejecutaría, y es capaz de analizar sintácticamente precondiciones de métodos para evitar la generación de casos de prueba poco interesantes.


%-------------------------------------------------------------------
\section{Objetivos}
%-------------------------------------------------------------------
\label{cap1:sec:objetivos}

En este proyecto se estudiará y desarrollará una herramienta de ``depuración simbólica'' que permitirá estudiar el funcionamiento de programas informáticos sin ser ejecutados, a base de observar todas sus posibles ramas de ejecución (hasta un cierto nivel) así como los correspondientes pares entrada-salida. Dicha herramienta podría ayudar enormemente a los estudiantes de iniciación a la programación, y en general a programadores inexpertos, a la hora de razonar acerca de la corrección de sus programas.

Sólo se utilizará como forma de comprobación, no como solucionador de errores ni sintácticos ni semánticos, es decir, no realiza la función de compilador; mostrará los resultados de ciertas posibles entradas para comprobar si ésa es la solución que esperabas, de no ser así, el alumno sabrá que el código estará mal planteado. Los alumnos que están empezando a programar en C++ saben si su programa compila gracias al entorno que estén utilizando pero les es más difícil de comprobar si su programa está correcto sin la ayuda de una interfaz o de algún medio para eso. Ahí es donde entra nuestra herramienta.

La herramienta contará con una interfaz de usuario, proporcionando varias ventajas adicionales: el alumno podrá ver y actualizar cómodamente, en todo momento, el código que desee probar, podrá tanto escribir un código desde cero como importar un código ya creado, por otro lado, la herramienta marcará el recorrido que se ha realizado de forma que el alumno podrá corregir posibles errores más rápidamente, por ejemplo, al encontrar un recorrido que no era el deseado.

Para ilustrar mejor el funcionamiento de nuestra herramienta detallamos aquí un pequeño ejemplo para una función cuya estructura es un pequeño decodificador:

\begin{center}
\fbox{
\begin{minipage}{2\textwidth}
\begin{tabbing}
\hspace*{1cm}\=\hspace*{1cm}\=\hspace*{1cm}\=\hspace*{1cm}\= \kill
function deco(int a, int b)\{\\
\>if (a>0)\\
\>\>if (b>0)\\
\>\>\>return 0;\\
\>\>else\\
\>\>\>return 1;\\
\>else\\
\>\>if (b>0)\\
\>\>\>return 2;\\
\>\>else\\
\>\>\>return 3;\\
\}
\end{tabbing}
\end{minipage}
}
\end{center}

La ejecución de este programa en nuestra herramienta generaría la siguiente tabla de resultados:

\begin{table}
\begin{center}
\begin{tabular}{| l | l | l | l ||}
\hline
nº & Variable y valor & Traza \\
\hline
1 & a=1 b=1 return=0 & 1,2,3 \\
\hline
2 & a=1 b=0 return=1 & 1,4,5 \\
\hline
3 & a=0 b=1 return=2 & 6,7,8 \\
\hline
4 & a=0 b=0 return=3 & 6,9,10 \\
\hline
\end{tabular}
\end{center}
\caption{Tabla de resultados para el código ejemplo}
\end{table}

Lo que significaría que para el primer resultado, las entradas valen en este caso {\it 1, 1} haciendo referencia a que son valores mayores que 0, y el valor del return es el valor de salida, y los números que indican la traza son los números de las líneas que se han recorrido del programa para esta solución.

Para poder obtener estos resultados, la herramienta hará uso de tres componentes principales, cuyo ciclo de ejecución será el detallado en la siguiente figura:

%\figura{Vectorial/esquemaEjecucion}{width=.9\textwidth}{fig:esquemaEjecucion}%
%{Figura que muestra el ciclo de ejecución de nuestra herramienta.}

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

Por tanto como hemos nombrado en el parrafo anterior la herramienta consta de tres partes diferenciadas, una herramienta desarrollada a través de Clang para obtener el arbol de sintaxis anotado con la información que nos interesa, a esta herramienta la hemos llamado ast2xmltool, la cual detallamos en el siguiente capítulo. La parte central del proyecto, es decir, el intérprete prolog que se encarga de obtener la traza de ejecución para la diferentes ramas del programa a través de sus entradas y salidas, esta parte la detallaremos en el tercer capítulo. Y por último, la herramienta que funciona como enlace entre las dos partes nombradas anteriormente y el usuario, la cual hemos denominado SymC++ y la detallaremos en el cuarto capítulo de esta memoria.

%Muchas veces, para ayudarnos en la búsqueda de posibles fallos, es aconsejable programar en módulos, es decir, utilizando subprogramas para encapsular el código mejor. Con nuestra herramienta podrás elegir el nombre de la función que quieres probar aunque haya muchas funciones escritas, esto es útil ya que podrás ir comprobando sólo las que quieras sin tener que cambiar el código.

%Este proyecto es muy ambicioso y posee una gran envergadura que supera las posibilidades de un proyecto de fin de carrera para ser abordado desde cero. Es por esto que nosotros, durante el desarrollo de este proyecto planteamos una herramienta que debe ser continuada en cursos posteriores para poder acaparar todas la sintaxis de C++ y para que pueda ser considerada una herramienta de depuración completa.

%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
