%---------------------------------------------------------------------
%
%                          Cap\'itulo 1
%
%---------------------------------------------------------------------

\chapter{Introducci\'on}

\pagestyle{plain}

\begin{FraseCelebre}
\begin{Frase}
If debugging is the process of removing bugs, then programming must be the process of putting them in...
\end{Frase}
\begin{Fuente}
Edsger Dijkstra.
\end{Fuente}
\end{FraseCelebre}

%-------------------------------------------------------------------
\section{Motivaci\'on de la propuesta}
%-------------------------------------------------------------------

El proyecto nace de la idea y necesidad de utilizar una herramienta \'util para los estudiantes de iniciaci\'on a la programaci\'on. El problema al que se enfrentan los estudiantes cuando los ejercicios a resolver crecen en complejidad, los programas tambi\'en y normalmente no se comportan como deben para todos los casos. Escribir programas totalmente correctos requiere el uso de una serie de metodolog\'ias que en general resultan muy complejas para los estudiantes en los primeros cursos. La mayor\'ia de ellos siguen una mec\'anica de prueba-error, es decir, escriben los programas sin pararse a pensar demasiado acerca de su correcci\'on, y luego los prueban para ver si se comportan como esperan. Estas pruebas normalmente no son lo suficientemente exhaustivas y por lo tanto los estudiantes no son ni siquiera conscientes de las incorrecciones de sus programas. Desgraciadamente, los mecanismos y herramientas que ayudan en el testing y depuraci\'on de programas son en general demasiado avanzados, como para poder ser utilizados por programadores inexpertos.

Dado este problema aparece nuestro proyecto, como una herramienta sencilla e intuitiva que pueda mostrar de un modo natural el recorrido de un programa por sus diferentes ramas y los resultados que obtendr\'ia en cada uno de ellos. Esta herramienta ofrecer\'a una soluci\'on a la verificaci\'on de programas sencillos para estudiantes de iniciaci\'on, y de este modo acercar las herramientas de testing y depuraci\'on de un modo m\'as f\'acil y visual.

La herramienta est\'a desarrollada para el lenguaje de C++, puesto que es el utilizado en los primeros cursos de los grados de las Facultades de Inform\'atica, Estudios Estad\'isticos y Matem\'aticas, y concretamente es el utilizado en la asignatura de primer curso de Fundamentos de Programaci\'on en nuestra Facultad.

%-------------------------------------------------------------------
\section{Estado del arte y trabajos relacionados}
%-------------------------------------------------------------------

En esta secci\'on se presentan los recursos y herramientas software disponibles que se han planteado como opciones a tener en cuenta a la hora de obtener apoyo en la realizaci\'on de nuestro proyecto.

%-------------------------------------------------------------------
\subsection{C++ y Clang}
%-------------------------------------------------------------------

%-------------------------------------------------------------------
\subsubsection*{C++, un lenguaje con historia}
%-------------------------------------------------------------------
\label{ap2:sec:c++}

C++ es un lenguaje de programaci\'on dise\~nado a mediados de los a\~nos 80 por Bjarne Stroustrup en los Laboratorios de Bell. [1] C++ naci\'o como extensi\'on del lenguaje de programaci\'on C, al mismo tiempo que proporciona un cierto n\'umero de caracter\'isticas que engalanan dicho lenguaje. El nombre de C++ fue propuesto por Rick Mascitti en el a\~no 1983, cuando el lenguaje fue utilizado por primera vez fuera de un laboratorio cient\'ifico. Hasta ese momento se hab\'ia utilizado el nombre de C con clases. 

Se puede decir que C++ es un lenguaje que abarca tres paradigmas de programaci\'on: la programaci\'on estructurada, la programaci\'on gen\'erica y la programaci\'on orientada a objetos. Es un lenguaje de programaci\'on intermedio, puesto que se puede utilizar tanto para el desarrollo r\'apido de aplicaciones, como para escribir software de bajo nivel, como drivers y componentes de sistemas operativos.

Actualmente existe un est\'andar, denominado ISO C++, al que se han adherido la mayor\'ia de los fabricantes de compiladores m\'as modernos. Existen tambi\'en algunos int\'erpretes, tales como ROOT. [2]

Las principales caracter\'isticas de este lenguaje son las facilidades que proporciona para la programaci\'on orientada a objetos y para el uso de plantillas o programaci\'on gen\'erica. Adem\'as posee una serie de propiedades dificiles de encontrar en otros lenguajes como es la posibilidad de redefinir los operadores o poder crear nuevos tipos, que se comporten como tipos fundamentales.

La elecci\'on de desarrollar nuestra herramienta para el lenguaje de C++ se ha basado en dos motivos, el primero ha sido su popularidad, puesto que seg\'un el ranking TIOBE, el cual recoge los lenguajes de programaci\'on m\'as usados, se encuentra en cuarta posici\'on, y el segundo motivo ha sido el uso de este lenguaje en los primeros cursos de programaci\'on como ya hemos se\~nalado anteriormente. [3]

%-------------------------------------------------------------------
\subsubsection*{Clang y LLVM}
%-------------------------------------------------------------------

Clang es un {\it front-end} de compilador para los lenguajes de programaci\'on C, C++, Objective-C y Objective-C++. Usa LLVM (anteriormente conocido como Low Level Virtual Machine, o M\'aquina Virtual de Nivel Bajo) como su {\it back-end} y ha sido parte del ciclo de lanzamiento de LLVM desde la versi\'on 2.6. Est\'a dise\~nado para ofrecer un reemplazo de GNU Compiler Collection (GCC). Es {\it open-source}, y varias compa\~n\'ias de software est\'an involucradas en su desarrollo, incluyendo a Google y Apple. Su c\'odigo fuente est\'a bajo la licencia University of Illinois/NCSA. El proyecto Clang incluye adem\'as un analizador est\'atico de software y varias herramientas de an\'alisis de c\'odigo. [4]

Por otro lado, LLVM es una infraestructura para desarrollar compiladores, escrita a su vez en el lenguaje de programaci\'on C++, que est\'a dise\~nada para optimizar el tiempo de compilaci\'on, el tiempo de enlazado, el tiempo de ejecuci\'on y el tiempo ocioso en cualquier lenguaje de programaci\'on que el usuario quiera definir. Implementado originalmente para compilar C y C++, el dise\~no agn\'ostico de LLVM con respecto al lenguaje, y el \'exito del proyecto han engendrado una amplia variedad de lenguajes, incluyendo Objective-C, Fortran, Ada, Haskell, bytecode de Java, Python, Ruby y otros.

LLVM suministra las capas intermedias de un sistema de compilado completo, tomando el c\'odigo en formato intermedio (IF, en sus siglas en ingl\'es) de un compilador y emitiendo un IF optimizado. Este nuevo IF puede ser convertido y enlazado en un c\'odigo ensamblador dependiente de la m\'aquina concreta para una plataforma objetivo. LLVM puede aceptar el IF generado por la cadena de herramientas GCC, permitiendo as\'i que sea utilizado con todos los lenguages que a su vez son aceptados por GCC. LLVM tambi\'en puede generar c\'odigo m\'aquina relocalizable en el momento de compilaci\'on o de enlazado, o incluso c\'odigo m\'aquina binario en el momento de ejecuci\'on. [5] \\ \\ \\ 

%-------------------------------------------------------------------
\subsection{Verificaci\'on y An\'alisis}
%-------------------------------------------------------------------

Actualmente el software es uno de los productos m\'as requeridos en el mundo. Tal demanda de software implica procesos de desarrollo m\'as intensos, exhaustivos y menos propensos a errores. Siendo la correcci\'on de fallos la etapa en la que m\'as recursos se invierten y en la que hay m\'as inter\'es por mejorar su eficiencia. 

A d\'ia de hoy en el mercado existen paquetes de herramientas capaces de ofrecer a los desarrolladores detecci\'on de errores y estudios sobre la ejecuci\'on de sus programas. Existen varias maneras de verificar la correctitud de un programa. [6]

%-------------------------------------------------------------------
\subsubsection*{Sistemas de tipos}
%-------------------------------------------------------------------

Asignar tipos de datos (tipificar) da significado a colecciones de bits. Los tipos de datos normalmente tienen asociaciones tanto con valores en la memoria o con objetos como con variables. Al igual que cualquier valor consiste en un conjunto de bits de un ordenador, el hardware no hace distinci\'on entre direcci\'on de memoria, c\'odigo de instrucci\'on, car\'acteres, enteros y n\'umeros en coma flotante. Los tipos de datos informan a los programas y programadores c\'omo deben ser tratados esos bits.

Al proceso de verificar e imponer los l\'imites por los tipos de datos, conocido como comprobaci\'on o checkeo de tipificaci\'on. Este proceso puede ocurrir tanto en la compilaci\'on (comprobaci\'on est\'atica) o en la ejecuci\'on (comprobaci\'on din\'amica). La elecci\'on entre sistemas de tipificaci\'on din\'amico y est\'atico requiere algunas contraprestaciones:

\begin{itemize}
\item El \textbf{tipado est\'atico} busca errores en los tipos de datos durante la compilaci\'on. Esto deber\'ia incrementar la fiabilidad de los programas procesados. Sin embargo, los programadores, normalmente, est\'an en desacuerdo en c\'omo los errores de tipos de datos m\'as comunes ocurren, y en qu\'e proporci\'on de estos errores que se han escrito podr\'ian haberse cazado con un tipado est\'atico.  Los defensores de los lenguajes fuertemente tipados han sugerido que casi todos los errores pueden ser considerados errores de los tipos de datos.
\item El \textbf{tipado din\'amico} permite a los compiladores e int\'erpretes ejecutarse m\'as r\'apidamente, debido a que los cambios en el c\'odigo fuente en los lenguajes din\'amicamente tipados puede resultar en menores comprobaciones y menos c\'odigo que revisar. Esto tambi\'en reduce el ciclo editar-compilar-comprobar-depurar. El tipado din\'amico t\'ipicamente hace que la metaprogramaci\'on sea m\'as poderosa y f\'acil de usar.
\end{itemize}


%-------------------------------------------------------------------
\subsubsection*{An\'alisis est\'atico}
%-------------------------------------------------------------------

El an\'alisis est\'atico de software es un tipo de an\'alisis que se realiza sin ejecutar el programa. En la mayor\'ia de los casos se realiza sobre el c\'odigo fuente y en otros casos se realiza sobre el c\'odigo objeto.

Dicho t\'ermino se aplica a los an\'alisis realizados por parte de una herramienta autom\'atica sobre el programa sin que este se ejecute. La industria ha reconocido los m\'etodos de an\'alisis est\'atico como elementos clave a la hora de mejorar la calidad de programas complejos. Un uso comercial creciente del an\'alisis est\'atico es la verificaci\'on de las propiedades de software utilizadas en sistemas inform\'aticos cr\'iticos para la seguridad y la localizaci\'on de c\'odigo vulnerable, pero tambi\'en se incluyen una viariedad de m\'etodos formales que verifican ciertas propiedades del programa. Por ejemplo, el uso de este tipo de an\'alisis est\'a muy extendido en los campos de la medicina, la aviaci\'on o la energ\'ia nuclear, donde no se pueden permitir errores ni riesgos.


%-------------------------------------------------------------------
\subsubsection*{Verificaci\'on de modelos (Model checking)}
%-------------------------------------------------------------------

La verificaci\'on de modelos (o Model checking) es un m\'etodo autom\'atico de verificaci\'on de un sistema formal, en la mayor\'ia de las ocasiones derivado del hardware o del software de un sistema inform\'atico. El sistema es descrito mediante un modelo, que debe satisfacer una especificaci\'on formal descrita mediante una f\'ormula, a menudo escrita en alguna variedad de l\'ogica temporal.

El modelo suele estar expresado como un sistema de transiciones, es decir, un grafo dirigido, que consta de un conjunto de v\'ertices y arcos. Un conjunto de proposiciones at\'omicas se asocia a cada nodo. As\'i pues, los nodos representan los estados posibles de un sistema, los arcos posibles evoluciones del mismo, mediante ejecuciones permitidas, que alteran el estado, mientras que las proposiciones representan las propiedades b\'asicas que se satisfacen en cada punto de la ejecuci\'on.

Formalmente, el problema se representa de la siguiente manera: Dada una propiedad deseada, expresada como una f\'ormula en l\'ogica temporal p, y un modelo M con un estado inicial s.

Los inventores del m\'etodo, Edmund M. Clarke, E. Allen Emerson y Joseph Sifakis, recibieron el Premio Turing 2007 de la ACM, en reconocimiento de su fundamental contribuci\'on al campo de las ciencias de la computaci\'on. [7]

%-------------------------------------------------------------------
\subsubsection*{Ejecuci\'on simb\'olica}
%-------------------------------------------------------------------

La ejecuci\'on simb\'olica o evaluaci\'on simb\'olica es una de las t\'ecnicas  m\'as potentes para el an\'alisis de programas. Esta t\'ecnica permite hacer razonamientos sobre programas en base a observar los comportamientos de cada uno de sus caminos de ejecuci\'on. Un int\'erprete recorre el programa donde cada variable asume un valor simb\'olico acotado. Este recorrido dar\'a como resultado expresiones en t\'erminos de dichos valores simb\'olicos por cada una de las ramas de ejecuci\'on. De este modo, obtendremos los resultados dependiendo del recorrido que hayan tomado las variables simb\'olicas, y gracias a este recorrido podremos determinar las condiciones que deben ser verificadas por los datos de ingreso para que un camino particular se ejecute, y la relaci\'on entre los valores ingresados y producidos en la ejecuci\'on de un programa.

El proceso de generaci\'on de casos de prueba por ejecuci\'on simb\'olica produce un conjunto de sistemas de restricciones que pueden entenderse como clases de equivalencia de entradas. As\'i, el conjunto posiblemente infinito de entradas de una clase de equivalencia llevar\'ia al programa a recorrer el mismo camino de ejecuci\'on. Estas clases de equivalencia se pueden entender por tanto como casos de prueba. Puesto que la ejecuci\'on simb\'olica razona en t\'erminos de caminos de ejecuci\'on, nos permite obtener un caso de prueba para cada camino de ejecuci\'on del programa, pudiendo garantizar as\'i un buen recubrimiento con un n\'umero reducido de casos de prueba.

Este procedicimiento aplicado al hardware recibe el nombre de simulaci\'on simb\'olica. [8]

Por otro lado, a\'un no se ha aplicado con \'exito en el contexto de programas concurrentes. Este problema plantea sin duda nuevos retos, al tener que combinar la complejidad inherente a la ejecuci\'on simb\'olica con aspectos de los programas concurrentes tales como la suspensi\'on de tareas, la sincronizaci\'on, las posibles estrategias de planificaci\'on de tareas, etc.

%La ejecuci\'on simb\'olica se encuentra en el n\'ucleo de multitud de herramientas, tales como generadores autom\'aticos de casos de prueba, verificadores, o visualizadores y depuradores de programas. Entre ellos vamos a destacar algunos de ellos:

%\begin{itemize}
%\item \textbf{}
%\end{itemize}
%

%-------------------------------------------------------------------
\subsection{Testing}
%-------------------------------------------------------------------

Paralelamente a las herramientas de verificaci\'on y an\'alisis nacen las pruebas de software(o testing en ingl\'es). Estas pruebas son investigaciones emp\'iricas y t\'ecnicas cuyo objetivo es proporcionar informaci\'on objetiva e independiente sobre la calidad del producto a la parte interesada.  

Estas pruebas se diferencian de las herramientas de verificaci\'on y an\'alisis en que garantizan la correctitud de los programas para esos test, pero es imposible que dichos test abarquen todas las posibilidades o ramas de ejecuci\'on de un programa, de tal modo que el programa podr\'ia no estar correcto para todas sus posibilidades como si garantiza la verificaci\'on y el an\'alisis. A continuaci\'on detallamos algunas de estas herramientas que ayudan a automatizar distintas fases del proceso de testing.

%-------------------------------------------------------------------
\subsubsection*{Frameworks xUnit}
%-------------------------------------------------------------------

Durante su trabajo en los laboratorios de Xerox Park, Kent Beck desarrollo un framework para realizar test unitarios en el lenguaje de programaci\'on {\it Smalltalk} que estaba desarrollando. Dicho framework se llamaba sUnit. sUnit Permit\'ia agrupar los tests en suites, el lanzamiento jer\'arquico de \'estos y realizar para cada test la comparaci\'on entre el valor obtenido y el valor esperado para determinar la correcci\'on de la funcionalidad testeada. Este framework ha sido llevado a una gran variedad de lenguajes de programaci\'on ({\it JUnit}, {\it XSLTUnit}, {\it PhpUnit}, {\it PyUnit}/ldots). xUnit es el nombre con el que se designa gen\'ericamente a todos estos frameworks. [9]

Una de las caracter\'isticas de los tests xUnit es la expansi\'on y el alto grado de utilizaci\'on de esta herramienta por todo el mundo.



%-------------------------------------------------------------------
\subsubsection*{Generaci\'on de tests}
%-------------------------------------------------------------------

El objetivo de las pruebas es presentar informaci\'on sobre la calidad del producto a las personas responsables, por tanto la informaci\'on requerida puede ser de lo m\'as variada. Esto hace que el proceso de testing sea dependiente del contexto, no existen las {\it mejores pruebas}, toda prueba puede ser ideal para una situaci\'on o completamente inutil o perjudicial para otra. A continuaci\'on detallamos algunas de los diferentes enfoques para la generaci\'on de tests: [10]

\begin{itemize}
\item \textbf{Pruebas de caja blanca} (white-box). Estas pruebas se centran en los detalles procedimentales del software, por lo que su dise\~no est\'a fuertemente ligado al c\'odigo fuente. El testeador escoge distintos valores de entrada para examinar cada uno de los posibles flujos de ejecuci\'on y cerciorarse de que se devuelven los valores de salida adecuados. Puesto que est\'an basados en una implementaci\'on concreta, si esta se modifica, normalmente tambi\'en tendr\'an que redise\~narse las pruebas. A pesar de que este enfoque permite dise\~nar pruebas que cubran una amplia variedad de casos podr\'ia pasar por alto partes incompletas de la especificaci\'on o requisitos faltantes.
\item \textbf{Pruebas de caja negra} (black-box). Estas pruebas se centran en el estudio de las entradas y las salidas generadas, independientemente de su funcionamiento interno, es decir, nos interesa su forma de interactuar entendiendo {\it qu\'e es lo que hace} pero sin importarnos el {\it c\'omo lo hace}. Las pruebas basadas en este sistema ser\'an m\'as f\'aciles de entender ya que permitir\'an dar una visi\'on m\'as clara del conjunto, el sistema tambi\'en ser\'a m\'as robusto y f\'acil de mantener, en caso de fallo este podr\'a ser aislado y abordado m\'as \'agilmente.
\item \textbf{Testing aleatorio} o random. Buscando ampliar el \'ambito de pruebas de unidad, se han aplicado diversas t\'ecnicas que van desde la automatizaci\'on de pasos, hasta los enfoques de generaci\'on de objetos de manera aleatoria. En este caso concreteo, la generaci\'on de tests de forma aleatoria es un caso particular de las pruebas de caja negra, donde las pruebas se realizan con entradas generadas de manera aleatoria e independiente. Los resultados se comparan con las especificaciones del software en prueba para verificar si los resultados pasan el test o no.
\end{itemize}

%-------------------------------------------------------------------
\subsection{Programaci\'on con restricciones}
%-------------------------------------------------------------------

La programaci\'on con restricciones es un paradigma de la programaci\'on en inform\'atica, donde las relaciones entre las variables son expresadas en terminos de restricciones o ecuaciones. Este paradigma representa uno de los mayores desarrollos en los lenguajes de programaci\'on desde 1990 y ha sido identificada como una direcci\'on estrat\'egica en la investigaci\'on en computaci\'on.

Se trata de un paradigma de programaci\'on basado en la especificaci\'on de un conjunto de restricciones las cuales deben ser satisfechas por cualquier soluci\'on del problema planteado, en lugar de especificar los pasos para obtener dicha soluci\'on. El enfoque de este tipo de programaci\'on se basa principalmente en especificar un estado en el cual una gran cantidad de restricciones sean satisfechas simultaneamente. Un problema se define t\'ipicamente como un estado de la realidad	en el cual existe un n\'umero de variables con valor desconocido. Un programa basado en restricciones busca dichos valores para todas las variables.

Actualmente existen muchos frentes de desarrollo relacionados con la programaci\'on con restricciones. Entre ellos destacan:
\begin{itemize}
\item Oz: Lenguaje multiparadigma y esot\'erico basado en la rama concurrente de la programaci\'on por restricciones. En el que se expresa m\'usica a partir de unas restricciones expresadas expl\'icitamente por el programador. Se utiliza en proyectos tales como Mozart y Strasheela. [11]
\item Choco: Es una librer\'ia que a\~nade satisfacci\'on de restricciones a Java. Est\'a construida en una estructura basada en la propagaci\'on de eventos. Ha sido utilizada en otros proyectos de ejecuci\'on simb\'olica como JsyX. [12]
\item Gecode: Es un proyecto abierto que cuenta con un conjunto de herramientas basado en C/C++ para el desarrollo de sistema y aplicaciones nativas que se apoyen en restricciones. [13]
\end{itemize}

La programaci\'on con restricciones se relaciona mucho con la programaci\'on l\'ogica, de hecho cualquier programa l\'ogico puede ser traducido a un programa con restricciones y viceversa, en muchas ocasiones los programas l\'ogicos son traducidos a programas con restricciones puesto que la soluci\'on es mucho m\'as eficiente. 

Los lenguajes de programaci\'on con restricciones son t\'ipicamente ampliaciones de otro lenguaje. El primer lenguaje utilizado a tal efecto fue Prolog. Por esta raz\'on este campo fue llamado inicialmente Programaci\'on L\'ogica con Restricciones.

La programaci\'on l\'ogica con restricciones es un caso particular de la programaci\'on con restricciones, en el cual la programaci\'on l\'ogica se extiende para incluir conceptos de la programaci\'on con restricciones. Por tanto, un programa l\'ogico con restricciones es un programa l\'ogico que contiene restricciones en el cuerpo de sus cla\'usulas. Por ejemplo, la cla\'usula {\it A(X,Y) :- X+Y>0, B(X), C(Y)} es un ejemplo de una cl\'ausula con restricciones donde {\it X+Y>0} es la restriccion y {\it B(X), C(Y)} son literales al igual que en programaci\'on l\'ogica.

Al igual que en la programaci\'on l\'ogica, los programas se ejecutan buscando demostrar un objetivo que puede contener restricciones adem\'as de los literales. Una prueba para un objetivo se compone de cla\'usulas cuyos cuerpos satisfacen las restricciones y literales que se pueden probar usando otras cla\'usulas. La ejecuci\'on se realiza a trav\'es de un int\'erprete, que empieza desde un objetivo y recursivamente escanea el resto de cla\'usulas para probar el objetivo.

%-------------------------------------------------------------------
\subsection{Trabajos relacionados}
%-------------------------------------------------------------------

Como hemos mencionado anteriormente, la ejecuci\'on simb\'olica no es algo nuevo y ha adquirido protagonismo en los \'ultimos a\~nos. Es por esto que podemos encontrar varios proyectos orientados al testing de diversos estilos, aqu\'i describimos algunos de ellos para contextualizar nuestro proyecto.

%-------------------------------------------------------------------
\subsubsection{PEX}
%-------------------------------------------------------------------

PEX es una herramienta desarrollada por Microsoft para la generaci\'on autom\'atica de casos de prueba. Esta herramienta genera entradas de test para programas .NET, por tanto puede analizar cualquier programa que se ejecute en una m\'aquina virtual .NET y soporta lenguajes como C\#, Visual Basic y F\#.

El enfoque de PEX se caracteriza por implementar la ejecuci\'on din\'amica simb\'olica, pero tambi\'en permite el uso de ejecucuci\'on concreta de valores para simplificar las restricciones, las cuales ser\'ian resuletas por el resolutor SMT. Por tanto, mediante un proceso iterativo, PEX realiza una ejecuci\'on concreta del m\'etodo a analizar y examina la traza de ejecuci\'on buscando ramas no exploradas. Una vez ha encontrado una rama no explorada, usa la ejecu-ci\'on simb\'olica y un sistema resolutor de restricciones para generar valores concretos que exploren dicha rama. Este proceso se repite hasta obtener el recubrimiento deseado.

El hecho de combinar la ejecuci\'on simb\'olica con la concreta permite en muchos casos incrementar la escalabilidad y tratar con situaciones donde la ejecuci\'on no depende s\'olo del c\'odigo sino de factores externos. Se entiende por factores externos el uso de librer\'ias nativas, llamadas al sistema operativo o interacciones con el usuario. Ante este tipo de situaciones, la ejecuci\'on simb\'olica presenta grandes limitaciones y en general, no se puede aplicar.

Esta herramienta se puede integrar en el entorno de desarrollo de Visual Studio facilitando su uso como un a\~nadido (Add\-on).

Como proyecto interesante relacionado con PEX existe el juego Code Hunt tambi\'en desarrollado por Microsoft. En este juego el jugador debe escribir c\'odigo para avanzar en el juego. La relaci\'oncon PEX es que lo que se muestra al jugador son las entradas y salidas, y mediante ejecuci\'on simb\'olica se evaluar\'a el c\'odigo escrito y de este modo poder avanzar. [14]

%-------------------------------------------------------------------
\subsubsection{PET}
%-------------------------------------------------------------------

PET (Partial Evaluation-based Test Case Generator for Bytecode) es una herramienta cuyo prop\'osito es generar casos de prueba de forma autom\'atica para programas escritos en bytecode (c\'odigo de bytes) de Java. PET adopta el enfoque previamente comentado, esto es, ejecuta el bytecode simb\'olicamente y devuelve como salida un conjunto de casos de prueba (test-cases). Cada caso de prueba est\'a asociado a una rama del \'arbol y se expresa como un conjunto de restricciones sobre los valores de entrada y una descripci\'on de los contenidos de la memoria din\'amica (o heap).

Las restricciones de la memoria din\'amica imponen condiciones sobre la forma y contenidos de las estructuras de datos del programa alojadas en esta misma. PET utiliza de un resolutor de restricciones que genera valores concretos a partir de estas restricciones, permitiendo la construcci\'on de los
tests propiamente dichos.

PET puede usarse a trav\'es de una interfaz de l\'inea de comandos o bien usando una interfaz web. Adem\'as soporta una variedad de opciones interesantes, como la elecci\'on de criterios de recubrimiento o la generaci\'on de tests jUnit. Estas opciones se describen con m\'as detalle en el segundo cap\'itulo. [15]

%-------------------------------------------------------------------
\subsubsection{jSYX}
%-------------------------------------------------------------------

jSYX es un proyecto desarrollado el curso pasado como trabajo de Sistemas Inform\'aticos. Este proyecto se basa en una m\'aquina virtual de Java que permite la ejecuci\'on simb\'olica de archivos .class de Java, de este modo puede ser utilizado para el desarrollo autom\'atico de Tests. 

El enfoque de jSYX es el uso de del Bytecode de Java como lenguaje de ejecuci\'on. Esta herramienta permite la ejecuci\'on recibiendo como par\'ametros una clase y su m\'etodo, y de este modo permite la ejecuci\'on simb\'olicamente o de manera concreta. Por otra lado se podr\'a obtener informaci\'on sobre el bytecode del archivo .class. [16]

%-------------------------------------------------------------------
\subsubsection{jPET}
%-------------------------------------------------------------------

Al igual que el detallado en la secci\'on anterior, jPET tambi\'en se trata de un proyecto de Sistemas Inform\'aticos, en este caso desarrollado durante el curso 2010/2011. Este proyecto se basa en PET, la herramienta detallada anteriormente, y es una extensi\'on de dicha herramienta para poder utilizarse en programas Java de alto nivel e integrarse en Eclipse, con el objetivo de poder usar los resultados obtenidos por PET durante el proceso de desarrollo de software.

El enfoque de jPET es el tratamiento de la informaci\'on generada por PET con el objetivo de presentarla al usuario de una manera m\'as f\'acil, sencilla e intuitiva. Es por esto que incorpora un visor de casos de prueba para mostrar el contenido de memoria antes y despu\'es de la ejecuci\'on, una herramienta de depuraci\'on, para ver los resultados mostrando la secuencia de instrucciones que el caso de prueba ejecutar\'ia, y es capaz de analizar sint\'acticamente precondiciones de m\'etodos para evitar la generaci\'on de casos de prueba poco interesantes. [17] [18]


%-------------------------------------------------------------------
\section{Objetivos, la herramienta SymC++}
%-------------------------------------------------------------------

La elaboraci\'on de este proyecto tiene como objetivo principal el desarrollo de una herramienta propia de ``depuraci\'on simb\'olica'' que permite la depuraci\'on de programas inform\'aticos sin la necesidad de ser ejecutados al mismo tiempo que permite trabajar a nivel de m\'etodos permiti\'endonos verificar funcionalidades sueltas. Esta herramienta pueda ser utilizada como un medio de apoyo a los estudiantes de iniciaci\'on a la programaci\'on, y en general a programadores inexpertos, a la hora de razonar acerca de la correcci\'on de sus programas

S\'olo se utilizar\'a como forma de comprobaci\'on, no como solucionador de errores tanto sint\'acticos como sem\'anticos, es decir, no realiza la funci\'on de compilador; mostrar\'a los resultados de la ejecuci\'on para ciertas posibles entradas y as\'i comprobar si \'esa es la soluci\'on que esperabas, de no ser as\'i, el alumno sabr\'a que el c\'odigo estar\'a mal planteado. Los alumnos que est\'an empezando a programar en C++ saben si su programa compila gracias al entorno que est\'en utilizando pero les es m\'as dif\'icil de comprobar si su programa est\'a correcto sin la ayuda de una interfaz o de alg\'una otra herramienta. Ah\'i es donde entra nuestra herramienta.

La herramienta contar\'a con una interfaz de usuario, proporcionando varias ventajas adicionales: el alumno podr\'a ver y actualizar c\'omodamente, en todo momento, el c\'odigo que desee probar, podr\'a tanto escribir un c\'odigo desde cero como importar un c\'odigo ya creado, por otro lado, la herramienta marcar\'a el recorrido que se ha realizado de forma que el alumno podr\'a corregir posibles errores m\'as r\'apidamente, por ejemplo, al encontrar un recorrido que no era el deseado.

Para ilustrar mejor el funcionamiento de nuestra herramienta detallamos aqu\'i un peque\~no ejemplo para una funci\'on cuya estructura es un peque\~no decodificador:

\lstinputlisting[caption=C\'odigo de ejemplo, style=customcpp]{Codigos/codigoEjemplo.cpp}

La ejecuci\'on del programa mostrado en el c\'odigo anterior en nuestra herramienta generar\'ia la tabla de resultados 1.1.

\begin{table}[ht]
\begin{center}
\begin{tabular}{| l | l | l | l ||}
\hline
nº & Variable y valor & Traza \\
\hline
1 & a=1 b=1 return=0 & 1,2,3 \\
\hline
2 & a=1 b=0 return=1 & 1,4,5 \\
\hline
3 & a=0 b=1 return=2 & 6,7,8 \\
\hline
4 & a=0 b=0 return=3 & 6,9,10 \\
\hline
\end{tabular}
\end{center}
\caption{Tabla de resultados para el c\'odigo ejemplo}
\end{table}

Esta tabla de resultados muestra en la primera columna el n\'umero correspondiente a la soluci\'on, en la segunda columna se muestra el valor de las variables de la soluci\'on, las cuales hacen referencia a las variables de entrada de la funci\'on y la variable de salida o return, y en la tercera columna se muestra la traza de ejecuci\'on, o lo que es lo mismo, los n\'umeros de l\'inea que ha recorrido el programa para llegar a dicha soluci\'on. Por tanto, para el primer resultado, las entradas valen en este caso {\it ``1, 1''} haciendo referencia a que son valores mayores que 0, y el valor del return es el valor de salida, por otro lado los n\'umeros que indican la traza son los n\'umeros de las l\'ineas que se han recorrido del programa para esta soluci\'on, en este caso {\it ``1, 2, 3''}, y as\'i sucesivamente para lo otros tres resultados.

Para llegar a esta soluci\'on, hemos desarrollado la herramienta denominada {\it SymC++}, el nombre surge de la relaci\'on con la ejecuci\'on simb\'olica y por estar desarrollada pensando en el lenguaje de programaci\'on C++.

Dicha herramienta har\'a uso de tres componentes principales, cuyo ciclo de ejecuci\'on detallamos en la siguiente figura:

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.9\textwidth]%
{Imagenes/Vectorial/esquemaEjecucion}
\caption{Figura que muestra el ciclo de ejecuci\'on de nuestra herramienta.}
\end{center}
\end{figure}

Por tanto como se puede observar en la figura anterior, la herramienta SymC++ consta de tres partes diferenciadas:

\begin{itemize}
\item \textbf{Ast2xml}: una herramienta desarrollada a trav\'es de Clang para obtener el arbol de sintaxis anotado con la informaci\'on que nos interesa, la cual detallamos en el siguiente cap\'itulo.
\item \textbf{Int\'erprete simb\'olico}: la parte central del proyecto, es decir, el int\'erprete prolog que se encarga de obtener las posibles soluciones para cada una de las ramas del programa, as\'i como la traza de ejecuci\'on a trav\'es de sus entradas y salidas, esta parte la detallaremos en el tercer cap\'itulo.
\item \textbf{Interfaz de usuario}: funciona como enlace entre las dos partes nombradas anteriormente y el usuario y la detallaremos en el cuarto cap\'itulo de esta memoria.
\end{itemize}



%Muchas veces, para ayudarnos en la b\'usqueda de posibles fallos, es aconsejable programar en m\'odulos, es decir, utilizando subprogramas para encapsular el c\'odigo mejor. Con nuestra herramienta podr\'as elegir el nombre de la funci\'on que quieres probar aunque haya muchas funciones escritas, esto es \'util ya que podr\'as ir comprobando s\'olo las que quieras sin tener que cambiar el c\'odigo.

%Este proyecto es muy ambicioso y posee una gran envergadura que supera las posibilidades de un proyecto de fin de carrera para ser abordado desde cero. Es por esto que nosotros, durante el desarrollo de este proyecto planteamos una herramienta que debe ser continuada en cursos posteriores para poder acaparar todas la sintaxis de C++ y para que pueda ser considerada una herramienta de depuraci\'on completa.

%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilaci\'on y funcionen mejor algunas teclas r\'apidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
