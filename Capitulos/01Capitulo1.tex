%---------------------------------------------------------------------
%
%                          Capítulo 1
%
%---------------------------------------------------------------------

\chapter{Introducción}

%-------------------------------------------------------------------
\section{Motivación de la propuesta}
%-------------------------------------------------------------------
\label{cap1:sec:motivacion}

El proyecto nace de la idea y la necesidad de utilizar una herramienta útil para los estudiantes de iniciación a la programación.

El problema al que se enfrentan los estudiantes es cuando los ejercicios a resolver crecen en complejidad, los programas también y normalmente no se comportan como deben para todos los casos. Escribir programas totalmente correctos requiere el uso de una serie de metodologías que en general resultan muy complejas para los estudiantes en los primeros cursos. La mayoría de ellos siguen una mecánica de prueba-error, es decir, escriben los programas sin pararse a pensar demasiado acerca de su corrección, y luego los prueban para ver si se comportan como esperan. Estas pruebas normalmente no son lo suficientemente exhaustivas y por lo tanto los estudiantes normalmente no son ni siquiera conscientes de las incorrecciones de sus programas. Desgraciadamente, los mecanismos y herramientas que ayudan en el testing y depuración de programas son en general demasiado avanzados, como por ejemplo lo son los para poder ser utilizados por programadores inexpertos.

En este caso concreto, la herramienta está desarrollada para el lenguaje de C++, puesto que es el utilizado en los primeros cursos de los grados de las Facultades de Informática, Estudios Estadísticos y Matemáticas, y concretamente es el utilizado en la asignatura de primer curso de Fundamentos de Programación en nuestra Facultad.

Dado este problema aparece nuestro proyecto, como una herramienta sencilla e intuitiva que pueda mostrar de un modo natural el recorrido de un programa por sus diferentes ramas y los resultados que obtendría en cada uno de ellos.

%-------------------------------------------------------------------
\section{Estado del arte y trabajos relacionados}
%-------------------------------------------------------------------
\label{cap1:sec:estytra}

%-------------------------------------------------------------------
\subsection{C++ y Clang}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

%-------------------------------------------------------------------
\subsubsection*{C++, un lenguaje con historia}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

C++ es un lenguaje de programación diseñado a mediados de los años 1980 por Bjarne Stroustrup en los Laboratorios de Bell. C++ nació como extensión del lenguaje de programación C, al mismo tiempo que proporciona un cierto número de características que \"engalanan\" dicho lenguaje. El nombre de C++ fue propuesto por Rick Mascitti en el año 1983, cuando el lenguaje fue utilizado por primera vez fuera de un laboratorio científico. Hasta ese momento se había utilizado el nombre de \"C con clases\". 

Se puede decir que C++ es un lenguaje que abarca tres paradigmas de programación: la programación estructurada, la programación genérica y la programación orientada a objetos. Es un lenguaje de programación intermedio, puesto que se puede utilizar tanto para escribir software de bajo nivel, como drivers y componentes de sistemas operativos, como para el desarrollo rápido de aplicaciones.

Actualmente existe un estándar, denominado ISO C++, al que se han adherido la mayoría de los fabricantes de compiladores más modernos. Existen también algunos intérpretes, tales como ROOT.

Las príncipales características de este lenguaje son las facilidades que proporciona para la programación orientada a objetos y para el uso de plantillas o programación genérica. Además posee una serie de propiedades dificiles de encontrar en otros lenguajes como es la posibilidad de redefinir los operadores o poder crear nuevos tipos, que se comporten como tipos fundamentales.

%-------------------------------------------------------------------
\subsubsection*{Clang y LLVM}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

Clang es un front end de compilador para los lenguajes de programación C, C++, Objective-C y Objective-C++. Usa LLVM como su back-end y ha sido parte del ciclo de lanzamiento de LLVM desde la versión 2.6. Está diseñado para ofrecer un reemplazo de GNU Compiler Collection (GCC). Es open-source, y varias compañías de software están involucradas en su desarrollo, incluyendo a Google y Apple. Su código fuente está bajo la licencia University of Illinois/NCSA. El proyecto Clang incluye además un analizador estático de software y varias herramientas de análisis de código.

Por otro lado, LLVM (anteriormente conocido como Low Level Virtual Machine, o Máquina Virtual de Nivel Bajo) es una infraestructura para desarrollar compiladores, escrita a su vez en el lenguaje de programación C++, que está diseñada para optimizar el tiempo de compilación, el tiempo de enlazado, el tiempo de ejecución y el \"tiempo ocioso\" en cualquier lenguaje de programación que el usuario quiera definir. Implementado originalmente para compilar C y C++, el diseño agnóstico de LLVM con respecto al lenguaje, y el éxito del proyecto han engendrado una amplia variedad de lenguajes, incluyendo Objective-C, Fortran, Ada, Haskell, bytecode de Java, Python, Ruby y otros.

LLVM suministra las capas intermedias de un sistema de compilado completo, tomando el código en formato intermedio (IF, en sus siglas en inglés) de un compilador y emitiendo un IF optimizado. Este nuevo IF puede ser convertido y enlazado en un código ensamblador dependiente de la máquina concreta para una plataforma objetivo. LLVM puede aceptar el IF generado por la cadena de herramientas GCC, permitiendo así que sea utilizado con todos los lenguages que a su vez son aceptados por GCC. LLVM también puede generar código máquina relocalizable en el momento de compilación o de enlazado, o incluso código máquina binario en el momento de ejecución.

%-------------------------------------------------------------------
\subsection{Verificación y Análisis}
%-------------------------------------------------------------------
\label{ap1:sec:c++}

Actualmente el software es uno de los productos más requeridos en el mundo. Tal demanda de software implica procesos de desarrollo más intensos, exhaustivos y menos prestos a errores. Siendo la corrección de fallos la etapa en la que más recursos se invierten y en la que hay más interés por mejorar su eficiencia. 

A día de hoy en el mercado existen paquetes de herramientas capaces de ofrecer a los desarrolladores detección de errores y estudios sobre la ejecución de sus programas. Existen varias maneras de verificar la correctitud de un programa.

%-------------------------------------------------------------------
\subsubsection*{Lógicas}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

%-------------------------------------------------------------------
\subsubsection*{Sistemas de tipos}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

Asignar tipos de datos (tipificar) da significado a colecciones de bits. Los tipos de datos normalmente tienen asociaciones tanto con valores en la memoria o con objetos como con variables. Como cualquier valor simplemente consiste en un conjunto de bits de un ordenador, el hardware no hace distinción entre dirección de memoria, código de instrucción, caracteres, enteros y números en coma flotante. Los tipos de datos informan a los programas y programadores cómo deben ser tratados esos bits.

Al proceso de verificar e imponer los límites impuestos por los tipos de datos, conocido como comprobación o checkeo de tipificación, puede ocurrir tanto en la compilación (comprobación estática) o en la ejecución (comprobación dinámica). La elección entre sistemas de tipificación dinámico y estático requiere algunas contraprestaciones:

\begin{itemize}
\item El tipado estático busca errores en los tipos de datos durante la compilación. Esto debería incrementar la fiabilidad de los programas procesados. Sin embargo, los programadores, normalmente, están en desacuerdo en cómo los errores de tipos de datos más comunes ocurren, y en qué proporción de estos errores que se han escrito podrían haberse cazado con un tipado estático.  Los defensores de los lenguajes fuertemente tipados han sugerido que casi todos los errores pueden ser considerados errores de los tipos de datos.
\item El tipado dinámico permite a los compiladores e intérpretes ejecutarse más rápidamente, debido a que los cambios en el código fuente en los lenguajes dinámicamente tipados puede resultar en menores comprobaciones y menos código que revisar. Esto también reduce el ciclo editar-compilar-comprobar-depurar. El tipado dinámico típicamente hace que la metaprogramación sea más poderosa y fácil de usar.
\end{itemize}


%-------------------------------------------------------------------
\subsubsection*{Análisis estático}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

El análisis estático de software es un tipo de análisis que se realiza sin ejecutar el programa. En la mayoría de los casos se realiza sobre el código fuente y en otros casos se realiza sobre el código objeto.

Dicho término se aplica a los análisis realizados por parte de una herramienta automática sobre el programa sin que este se ejecute. La industria ha reconocido los métodos de análisis estático como elementos clave a la hora de mejorar la calidad de programas complejos. Un uso comercial creciente del análisis estático es la verificación de las propiedades de software utilizadas en sistemas informáticos críticos para la seguridad y la localización de código vulnerable, pero también se incluyen una viariedad de métodos formales que verifican ciertas propiedades del programa. Por ejemplo, el uso de este tipo de análisis está muy extendido en los campos de la medicina, la aviación o la energía nuclear, donde no se pueden permitir errores ni riestos.


%-------------------------------------------------------------------
\subsubsection*{Chequeo de modelos (Model checking)}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

La verificación de modelos (o Model checking) es un método automático de verificación de un sistema formal, en la mayoría de las ocasiones derivado del hardware o del software de un sistema informático. El sistema es descrito mediante un modelo, que debe satisfacer una especificación formal descrita mediante una fórmula, a menudo escrita en alguna variedad de lógica temporal.

El modelo suele estar expresado como un sistema de transiciones, es decir, un grafo dirigido, que consta de un conjunto de vértices y arcos. Un conjunto de proposiciones atómicas se asocia a cada nodo. Así pues, los nodos representan los estados posibles de un sistema, los arcos posibles evoluciones del mismo, mediante ejecuciones permitidas, que alteran el estado, mientras que las proposiciones representan las propiedades básicas que se satisfacen en cada punto de la ejecución.

Formalmente, el problema se representa de la siguiente manera: Dada una propiedad deseada, expresada como una fórmula en lógica temporal p, y un modelo M con un estado inicial s; decidir si M,s \models p.

Los inventores del método, Edmund M. Clarke, E. Allen Emerson y Joseph Sifakis, recibieron el Premio Turing 2007 de la ACM, en reconocimiento de su fundamental contribución al campo de las ciencias de la computación.

%-------------------------------------------------------------------
\subsubsection*{Ejecución simbólica}
%-------------------------------------------------------------------
\label{ap2:sec:clang}

Es un caso particular de Interpretación abstracta. Consiste en analizar el programa para luego concluir qué conjunto de entradas ejecutan qué partes del código. Un intérprete recorre el programa asumiendo valores simbólicos para las entradas en vez de solicitarlas al usuario, llegando al final con un conjunto de expresiones en términos de esos valores simbólicos de los cuales deduce los posibles valores reales. Este procedimiento aplicado al hardware recibe el nombre de Simulación simbólica.





%-------------------------------------------------------------------
\subsubsection{Revisiones (Software Reviews)}
%-------------------------------------------------------------------
\label{ap1:sec:revisiones}

Hechas por personas, por lo general involucradas en el proceso de desarrollo, expertas en la materia. Son reuniones en las que los revisores analizan el código y lo estudian en grupo con el objetivo de encontrar errores. Existen protocolos estandarizados por la asociación IEEE que rigen el orden de estas revisiones. Dependiendo de los conductores del análisis y del objetivo de este, cambia la denominación de la revisión.

%-------------------------------------------------------------------
\subsubsection*{Peer Review}
%-------------------------------------------------------------------
\label{ap1:peer}

Realizada por el propio autor del código o un compañero y su objetivo es evaluar el contenido técnico y la calidad del software.

%-------------------------------------------------------------------
\subsubsection*{Management Reviews}
%-------------------------------------------------------------------
\label{ap2:management}

Cuentan con la asistencia de los directivos o superiores, el objetivo es comprobar el trabajo realizado y sopesar el trabajo futuro.

%-------------------------------------------------------------------
\subsubsection*{Audit Reviews}
%-------------------------------------------------------------------
\label{ap2:audit}

La realiza personal externo al proyecto y busca irregularidades en cuanto a las especificaciones, estándares o acuerdos empresariales.

%-------------------------------------------------------------------
\subsubsection{Análisis dinámico}
%-------------------------------------------------------------------
\label{ap1:sec:dinamico}

Supone la ejecución del programa y observar su comportamiento. Para que el anáilisis sea efectivo de debe realizar con los suficientes casos de prueba. 
Estos casos de prueba representan los comportamientos que se esperan del programa en distintas condiciones de ejecución. Para asegurar la efectividad de las pruebas se pueden usar distintas técnicas como estudiar la cobertura del código (comprobar que en diferentes ejecuciones de un programa se pasa por todas las instruccciones al menos una vez) o el uso de programas fuzzers que ayudan a asegurar que una porción adecuada del conjunto de posibles comportamientos del programa ha sido observada.

%-------------------------------------------------------------------
\subsubsection*{Verificacion de modelos(Model cheking)}
%-------------------------------------------------------------------
\label{ap1:verificacion}

Método en el cual el programa y su especificación se expresan matemáticamente con el objetivo de verivicar su correctitud.

%-------------------------------------------------------------------
\subsubsection*{Lógica de Hoare}
%-------------------------------------------------------------------
\label{ap1:hoare}

Se emplea un sistema con un conjunto de reglas lógicas con las que razonar rigurosamente la correctitud del programa.

%-------------------------------------------------------------------
\subsubsection*{Análisis del flujo de datos}
%-------------------------------------------------------------------
\label{ap2:flujo}

Es una técnica en la que se recoge información acerca del conjunto de posibles valores calculados en distintos puntos del programa. Se utiliza para estudiar a que partes del programa se podría propagar un valor en particular asginado a una variable. 

%-------------------------------------------------------------------
\subsubsection*{Interpretación abstracta}
%-------------------------------------------------------------------
\label{ap3:abstracta}

Es un método que modela el efecto de las instrucciones del programa en la máquina mediante una ``ejecución'' basada en las propiedades matemáticas de cada instrucción. La máquina sobre la que ésta se lleva a cabo es una representación simplificada de la máquina verdadera. Esta máquina abstracta aproxima el comportamiento del sistema haciéndolo más fácil de analizar.

%-------------------------------------------------------------------
\section{Trabajos relacionados}
%-------------------------------------------------------------------
\label{cap1:sec:trabajos}

Como hemos mencionado anteriormente la ejecución simbólica, no es algo nuevo y ha adquirido protagonismo en los últimos años. Es por esto que podemos encontrar varios proyectos orientados al testing de diversos estilos, aquí describimos algunos de ellos para contextualizar nuestro proyecto.

%-------------------------------------------------------------------
\subsection{PEX}
%-------------------------------------------------------------------
\label{ap1:sec:pex}

PEX es una herramienta desarrollada por Microsoft par a la generación automática de casos de prueba. Esta herramienta genera entradas de test para programas .NET, por tanto puede analizar cualquier programa que se ejecute en una máquina virtual .NET y soporta lenguajes como C\#, Visual Basic y F\#.

El enfoque de PEX se caracteriza por implementar la ejecución dinámica simbólica, pero también permite el uso de ejecucución concreta de valores para simplificar las restricciones, las cuales serían resuletas por el resolutor SMT. Por tanto, mediante un proceso iterativo, PEX realiza una ejecución concreta del método a analizar y examina la traza de ejecución buscando ramas no exploradas. Una vez ha encontrado una rama no explorada, usa la ejecu-ción simbólica y un sistema resolutor de restricciones para generar valores concretos que exploren dicha rama. Este proceso se repite hasta obtener el recubrimiento deseado.

El hecho de combinar la ejecución simbólica con la concreta permite en muchos casos incrementar la escalabilidad y tratar con situaciones donde la ejecución no depende sólo del código sino de factores externos. Se entiende por factores externos el uso de librerías nativas, llamadas al sistema operativo o interacciones con el usuario. Ante este tipo de situaciones, la ejecución simbólica presenta grandes limitaciones y en general, no se puede aplicar.

Esta herramienta se puede integrar en el entorno de desarrollo de Visual Studio facilitando su uso como un añadido (Add\-on).

Como proyecto interesante relacionado con PEX existe el juego Code Hunt también desarrollado por Microsoft. En este juego el jugador debe escribir código para avanzar en el juego. La relacióncon PEX es que lo que se muestra al jugador son las entradas y salidas, y mediante ejecución simbólica se evaluará el código escrito y de este modo poder avanzar.

%-------------------------------------------------------------------
\subsection{PET}
%-------------------------------------------------------------------
\label{ap2:sec:pet}

PET (Partial Evaluation-based Test Case Generator for Bytecode) es una herramienta cuyo propósito es generar casos de prueba de forma automática para programas escritos en bytecode (código de bytes de Java). PET adopta el enfoque previamente comentado, esto es, ejecuta el bytecode simbólicamente y devuelve como salida un conjunto de casos de prueba (test-cases). Cada caso de prueba está asociado a una rama del árbol y se expresa como un conjunto de restricciones sobre los valores de entrada y una descripción de los contenidos de la memoria dinámica (o heap).

Las restricciones de la memoria dinámica imponen condiciones sobre la forma y contenidos de las estructuras de datos del programa alojadas en esta misma. PET utiliza de un resolutor de restricciones que genera valores concretos a partir de estas restricciones, permitiendo la construcción de los
tests propiamente dichos.

PET puede usarse a través de una interfaz de línea de comandos o bien usando una interfaz web. Además soporta una variedad de opciones interesantes, como la elección de criterios de recubrimiento o la generación de tests jUnit. Estas opciones se describen con más detalle en el segundo capítulo.

%-------------------------------------------------------------------
\subsection{jSYX}
%-------------------------------------------------------------------
\label{ap3:sec:jsyx}

jSYX es un proyecto desarrollado el curso pasado como trabajo de Sistemas Informáticos. Este proyecto se basa en una máquina virtual de Java que permite la ejecución simbólica de archivos .class de Java, de este modo puede ser utilizado para el desarrollo automático de Tests. 

El enfoque de jSYX es el uso de del Bytecode de Java como lenguaje de ejecución. Esta herramienta permite la ejecución recibiendo como parámetros una clase y su método, y de este modo permite la ejecución simbólicamente o de manera concreta. Por otra lado se podrá obtener información sobre el bytecode del archivo .class.

%-------------------------------------------------------------------
\subsection{jPET}
%-------------------------------------------------------------------
\label{ap4:sec:jpet}

Al igual que el detallado en la sección anterior, jPET también se trata de un proyecto de Sistemas Informáticos, en este caso desarrollado durante el curso 2010/2011. Este proyecto se basa en PET, la herramienta detallada anteriormente, y es una extensión de dicha herramienta para poder utilizarse en programas Java de alto nivel e integrarse en Eclipse, con el objetivo de poder usar los resultados obtenidos por PET durante el proceso de desarrollo de software.

El enfoque de jPET es el tratamiento de la información generada por PET con el objetivo de presentarla al usuario de una manera más fácil, sencilla e intuitiva. Es por esto que incorpora un visor de casos de prueba para mostrar el contenido de memoria antes y después de la ejecución, una herramienta de depuración, para ver los resultados mostrando la secuencia de instrucciones que el caso de prueba ejecutaría, y es capaz de analizar sintácticamente precondiciones de métodos para evitar la generación de casos de prueba poco interesantes.


%-------------------------------------------------------------------
\section{Objetivos}
%-------------------------------------------------------------------
\label{cap1:sec:objetivos}

En este proyecto se estudiará y desarrollará una herramienta de ``depuración simbólica'' que permitirá estudiar el funcionamiento de programas informáticos sin ser ejecutados, a base de observar todas sus posibles ramas de ejecución (hasta un cierto nivel) así como los correspondientes pares entrada-salida. Dicha herramienta podría ayudar enormemente a los estudiantes de iniciación a la programación, y en general a programadores inexpertos, a la hora de razonar acerca de la corrección de sus programas.

Sólo se utilizará como forma de comprobación, no como solucionador de errores ni sintácticos ni semánticos, es decir, no realiza la función de compilador; mostrará los resultados de ciertas posibles entradas para comprobar si ésa es la solución que esperabas, de no ser así, el alumno sabrá que el código estará mal planteado. Los alumnos que están empezando a programar en C++ saben si su programa compila gracias al entorno que estén utilizando pero les es más difícil de comprobar si su programa está correcto sin la ayuda de una interfaz o de algún medio para eso. Ahí es donde entra nuestra herramienta.

La herramienta contará con una interfaz de usuario, proporcionando varias ventajas adicionales: el alumno podrá ver y actualizar cómodamente, en todo momento, el código que desee probar, podrá tanto escribir un código desde cero como importar un código ya creado, por otro lado, la herramienta marcará el recorrido que se ha realizado de forma que el alumno podrá corregir posibles errores más rápidamente, por ejemplo, al encontrar un recorrido que no era el deseado.

Muchas veces, para ayudarnos en la búsqueda de posibles fallos, es aconsejable programar en módulos, es decir, utilizando subprogramas para encapsular el código mejor. Con nuestra herramienta podrás elegir el nombre de la función que quieres probar aunque haya muchas funciones escritas, esto es útil ya que podrás ir comprobando sólo las que quieras sin tener que cambiar el código.

Este proyecto es muy ambicioso y posee una gran envergadura que supera las posibilidades de un proyecto de fin de carrera para ser abordado desde cero. Es por esto que nosotros, durante el desarrollo de este proyecto planteamos una herramienta que debe ser continuada en cursos posteriores para poder acaparar todas la sintaxis de C++ y para que pueda ser considerada una herramienta de depuración completa.

%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
