%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------

\chapter{Intérprete con restricciones}

%-------------------------------------------------------------------
\section{Introducción}
%-------------------------------------------------------------------
\label{cap3:sec:introduccion}

En este capítulo hablaremos sobre la parte principal de nuestro proyecto. Esta consiste en el intérprete que recibe el árbol sintáctico de la herramienta AST2XML. El cometido del intérprete, a grandes rasgos, será el de realizar una ejecución simbólica del código devolviendo un conjunto de valores de entrada y salida que se corresponden con lo programado..


%-------------------------------------------------------------------
\section{Implementacion}
%-------------------------------------------------------------------
\label{cap3:sec:implementacion}

Como ya hemos indicado antes, AST2XML devuelve un archivo en formato XML con una versión simplificada del árbol sintáctico que emplea Clang con el que realizaremos la ejecución simbólica. Para llevar a cabo una ejecución simbólica es necesario tener un sistema capaz de establecer restricciones lógicas y matemáticas y que aparte las pueda resolver.

%-------------------------------------------------------------------
\section*{Programación por restricciones}
%-------------------------------------------------------------------
\label{ap1:prog}

La Programación por restricciones es un paradigma de la programación en informática donde las las variables está relacionadas mediante restricciones (ecuaciones). Se emplea en la descripción y resolución de problemas combinatorios, especialmente en las áreas de planificación y programación de tareas (calendarización). La programación con restricciones se basa principalmente en buscar un estado en el cual una gran cantidad de restricciones sean satisfechas simultáneamente, expresándose un problema como un conjunto de restricciones iniciales a partir de las cuales el sistema construye las relaciones que expresan una solución.
Actualmente existen muchos frentes de desarrollo relacionados con la programción con restricciones. Entre ellos destacan:
Oz: Lenguaje multiparadigma y esotérico basado en la rama concurrente de la programación por restricciones. En él que se expresa música a partir de unas restricciones expresadas explícitamente por el programador. Se utiliza en proyectos tales como Mozart y Strasheela.
Choco: Es una librería que añade satisfacción de restricciones a Java. Está construida en una estructura basada en la propagación de eventos. Ha sido utilizada en otros proyectos de ejecución simbólica como JsyX.
Gecode: Es un proyecto abierto que cuenta con un conjunto de herramientas basado en C/C++ para el desarrollo de sistema y aplicaciones nativas que se apoyen en restricciones. 

http://ktiml.mff.cuni.cz/~bartak/downloads/WDS99.pdf
La programación por restricciones está intimamente relacionada con la programación lógica. Por ende existe la programación lógica con restricciones. Ésta es una extensión de la programación lógica en la que se añade el concepto de satisfacción de restricciones. 

Para el desarrollo de nuestro intérprete optamos por el lenguaje de programación lógica Prolog. En gran parte debido a la familiaridad que nos supone y al conjunto de facilidades relacionadas con la programación por restricciones que ya conocíamos de antemano

%-------------------------------------------------------------------
\section{Prolog}
%-------------------------------------------------------------------
\label{cap3:sec:prolog}

La Programación Lógica tiene sus orígenes más cercanos en los trabajos de prueba automática de teoremas de los años sesenta. J. A. Robinson propone en 1965 una regla de inferencia a la que llama resolución, mediante la cual la demostración de un teorema puede ser llevada a cabo de manera automática. La resolución es una regla que se aplica sobre cierto tipo de fórmulas del Cálculo de Predicados de Primer Orden, llamadas cláusulas y la demostración de teoremas bajo esta regla de inferencia se lleva a cabo por reducción al absurdo. La realización del paradigma de la programación lógica es el lenguaje Prolog

Prolog es un  lenguaje de programación ideado a principios de los años 70 en la Universidad de Aix-Marseille I (Marsella, Francia). No tiene como objetivo la traducción de un lenguaje de programación, sino la clasificación algorítmica de lenguajes naturales. [1]

%-------------------------------------------------------------------
\section{Conceptos de Prolog}
%-------------------------------------------------------------------
\label{cap3:sec:prolog2}

La programación lógica tiene sus raíces en el cálculo de predicados. Es un conjunto de cláusulas de la forma: ``q :- p'', es decir, si p es cierto entonces q es cierto. Una cláusula pueden ser un conjunto de hechos positivos, por ejemplo de la forma ``q :- p, r, s.'' ; una implicación con un único consecuente, ``q :- p'' ; un hecho positivo, ``p.'' ; instrucciones con parámetros de Entrada/Salida ``p(Entrada,Salida).'' ; o incluso llamadas a otras funciones.

En Prolog, los predicados se contrastan en orden , la ejecución se basa en dos conceptos: la unificación y el backtracking. Una vez ejecutamos una función de Prolog se sigue ejecutando el programa gracias a las llamadas a predicados, si procede, hasta determinar si el objetivo es verdadero o falso. Todos los objetivos terminan su ejecución en éxito (``verdadero''), o en fracaso (``falso''). Si el resultado es falso entra en juego el backtracking, es decir, deshace todo lo ejecutado situando el programa en el mismo estado en el que estaba justo antes de llegar al punto de elección, ahí se toma el siguiente punto de elección que estaba pendiente y se repite de nuevo el proceso, de ahí la utilidad de prolog en nuestro proyecto.

%-------------------------------------------------------------------
\section{Aspectos relevantes de la implementación}
%-------------------------------------------------------------------
\label{cap3:sec:relevante}

Hemos utilizado la programación lógica basada en restricciones que consiste en reemplazar la unificación de términos de la programación lógica por el manejo de restricciones en un dominio concreto, es un algoritmo especializado e incremental ya que cuando se añade una nueva restricción a un conjunto de restricciones ya resuelto, el resolvedor de restricciones no tiene que resolver el conjunto de restricciones S desde el principio.

Una ventaja de la incorporación de las restricciones al lenguaje de programación es la sencillez al mostrar restricciones como datos de salida. La programación lógica basada en restricciones sobre dominios finitos (use\_module(library(clpfd))) proporciona una aritmética completa para variables restringidas a valores enteros o elementos atómicos. 

%-------------------------------------------------------------------
\section{Diseño del intérprete}
%-------------------------------------------------------------------
\label{cap3:sec:diseño}

El intérprete está encapsulado en dos módulos para hacer más fácil su diseño: VariablesTable.pl e Interpreter.pl. 

%-------------------------------------------------------------------
\section*{VariablesTable.pl}
%-------------------------------------------------------------------
\label{ap1:varTab}

El intérprete irá guardando las variables y su respectivo valor en una tabla de variables representado en prolog mediante una lista, de forma que todas las posibles operaciones que se puedan aplicar sobre ella estén encapsuladas en un mismo módulo. Por ejemplo, funciones como añadir un elemento a la tabla (add), obtener el valor de una variable (getValue), modificar el nombre de una variable (updateNames), etc. son funciones que sólo se aplican sobre la tabla de variables.

%-------------------------------------------------------------------
\section*{Interpreter.pl}
%-------------------------------------------------------------------
\label{ap2:inter}

Por otro lado, este módulo representa el Intérprete que será llamado por la interfaz y el que devolverá la solución. Los parámetros de entrada son: fichero de entrada, fichero de salida, Inf, Sup, MaxDepth y nombre de función.

Fichero de entrada
Indica el nombre del fichero .xml donde está el código traducido por clang. 

\figura{Vectorial/figura3}{width=.5\textwidth}{fig:figura3}%
{Figura con ejemplo de archivo XML de entrada.}

Fichero de salida
Indica el nombre del fichero .xml de salida que el intérprete devolverá con las soluciones para una determinada función.

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

Inf, Sup y MaxLoop
Inf y Sup son los valores que representan el límite del dominio de los valores de entrada de la función a interpretar. MaxLoop representa el valor del número máximo de veces que puede ejecutarse una estructura de control: while y for.

Nombre de función
Para indicar el nombre de la función que vamos a querer probar entre todas las funciones posibles contenidas en el fichero pasado en ``Fichero de entrada''.

%-------------------------------------------------------------------
\section{Ciclo de ejecución del intérprete}
%-------------------------------------------------------------------
\label{cap3:sec:ciclo}

El primer paso en la ejecución es la lectura del fichero xml y la conversión de la estructura en nodos a una de listas mediante la función que nos aporta la librería sgml:

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

nos saldría una lista así:

\figura{Vectorial/Todo}{width=.5\textwidth}{fig:todo}%
{Figura utilizada para marcar una imagen por hacer.}

Teniendo esto en cuenta simplificamos . Cada element tiene tres argumentos: el nombre del nodo, los atributos del nodo y el cuerpo del nodo.
De esta forma buscaremos previamente la función que el usuario nos haya indicado e iremos pasando por cada una de las instrucciones del código de dicha función y ejecutándolas mediante las sucesivas llamadas a la función execute.

%-------------------------------------------------------------------
\section*{execute/3}
%-------------------------------------------------------------------
\label{ap1:execute}

Es un predicado cuyos argumentos son: el estado previo a la ejecución de unas instrucciones, la lista que contiene las instrucciones y el estado posterior a la ejecución. Este predicado se planteó de forma que pudiéramos controlar cada una de las posibles instrucciones que puede llegar a haber en el código. Para conseguirlo en cada una de estas posibilidades expresamos explícitamente los casos de forma que la instrucción que se ejecuta en un momento dado es el primer elemento de la lista de instrucciones que recibe la función. Una vez se hayan completado los pasos que simulan el comportamiento de dicha instrucción se hace una ``llamada'' recursiva a execute con el estado resultante de la ejecución, el resto de la lista de instrucciones y el estado posterior. 

Esta forma de realizar los pasos de cómputo se asemeja, en un aspecto más teórico, a la semántica de paso corto (semántica operacional), aunque dicha similitud no es completa puesto que al trabajar con instrucciones puntuales llevamos a cabo muchos pasos intermedios.

Es importante destacar que el bactracking inherente de prolog se restringe en el predicado execute. Esto se debe a que el orden de las instrucciones es siempre el mismo. En el intérprete hemos limitado el backtracking a la evaluación de condiciones puesto que éstas son las que realmente definen el flujo del programa. Es por ello que en las instrucciones de control llegamos a necesitar la presencia de otros predicados que además de dirigir el comportamiento de la ejecución permiten limitar el número de repeticiones que realiza un bucle. 

%-------------------------------------------------------------------
\section*{executeLoop/5}
%-------------------------------------------------------------------
\label{ap2:execute2}

%-------------------------------------------------------------------
\section*{executeBranch/4}
%-------------------------------------------------------------------
\label{ap3:execute3}

%-------------------------------------------------------------------
\section*{resolveExpression/4}
%-------------------------------------------------------------------
\label{ap4:execute4}

%-------------------------------------------------------------------
\section*{work/3}
%-------------------------------------------------------------------
\label{ap1:execute4}

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
